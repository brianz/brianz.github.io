<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Brian Z</title>
    <link>http://blog.brianz.bz/tags/python/index.xml</link>
    <description>Recent content in Python on Brian Z</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017. All rights reserved.</copyright>
    <atom:link href="http://blog.brianz.bz/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Elixir for Pythonistas part I</title>
      <link>http://blog.brianz.bz/post/elixir-for-pythonistas-i/</link>
      <pubDate>Fri, 07 Apr 2017 16:02:32 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/elixir-for-pythonistas-i/</guid>
      <description>

&lt;p&gt;For the past many &lt;em&gt;many&lt;/em&gt; years my goto language has been Python. I&amp;rsquo;ve written all sorts of
applications using Python:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Django web apps&lt;/li&gt;
&lt;li&gt;Client side GUI applications with PyQt&lt;/li&gt;
&lt;li&gt;Data science stuff with numpy, pandas, etc.&lt;/li&gt;
&lt;li&gt;Alexa applications&lt;/li&gt;
&lt;li&gt;Serverless systems and web APIs&lt;/li&gt;
&lt;li&gt;Microservices and a &lt;a href=&#34;https://github.com/brianz/servant&#34; target=&#34;_blank&#34;&gt;microservice library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Many backend services to power various SAAS and non-SAAS applications&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Whenever there is some type of problem I need to solve programatically, I reach for Python. Sure,
I can be effective in other languages, but by and large, I&amp;rsquo;m a Python guy.&lt;/p&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;

&lt;p&gt;Not too long ago I counted it up&amp;hellip;over the past seven years I&amp;rsquo;ve worked at three companies all
which had these things in common:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python web stacks&lt;/li&gt;
&lt;li&gt;Django&lt;/li&gt;
&lt;li&gt;Spaghetti code which is (extremely) hard to reason about and evolve&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Where I landed many months ago was being unhappy and unsatisfied with Django and all of the
wrong decisions which are easy to make when using it to build a web application. I don&amp;rsquo;t think
this is necessarily a problem with Python or
Django themselves, however I do feel that both Python and Django make it really easy to make the
poor decisions when architecting a web application. If anything, Django is an enabler (and guilt by
association, Python).  Node and JavaScript are probably even worse and more enabling at bad
patterns.  Rails and Ruby, yes&amp;hellip;although with Rails there are such strong conventions around the
&amp;ldquo;Rails way&amp;rdquo; that at least people don&amp;rsquo;t have to look very far to figure out the &amp;ldquo;right&amp;rdquo; way of doing
something (don&amp;rsquo;t take this as an endorsement&amp;hellip;I believe this creates a community which freaks out
if they don&amp;rsquo;t have an existing pattern to copy/paste).&lt;/p&gt;

&lt;p&gt;Django makes it very easy to couple
different parts of your application together, in spite of your best intentions.  I would venture
to say that most of this comes down to the ORM.  Want to import some models from a completely
different part of your application and start firing off queries?  No problem.  Want to write a
triple nested loop over a queryset and fire off 1M+ DB statements? Sure! (Note, I &lt;em&gt;have&lt;/em&gt; seen
this done and spent weeks fixing it). Need some data in your template?  Just shove an &lt;code&gt;all()&lt;/code&gt;
queryset in your template and iterate to your hearts content.  This works &lt;em&gt;great&lt;/em&gt; when you have 10
rows in your table, not so much when you have 1M rows.&lt;/p&gt;

&lt;p&gt;Where I&amp;rsquo;m going is that I said to myself&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There must be a better way&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-possible-solution&#34;&gt;The (possible) solution&lt;/h2&gt;

&lt;p&gt;Slowly, I&amp;rsquo;ve been digging into Elixir. Why?  I wanted to learn and use a functional language to see
if it would solve some of the problems I&amp;rsquo;ve hit with imperative languages like Python. Here are a
few other things which helped point me in the Elixir direction:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Erlang VM (BEAM)

&lt;ul&gt;
&lt;li&gt;Ability for some massive concurrency&lt;/li&gt;
&lt;li&gt;Built-in messaging (hello microservices)&lt;/li&gt;
&lt;li&gt;Possibility of hot-loading new code&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Picking up lots of steam mostly from the Rails community. But the bottom line is that the &amp;ldquo;there
must be a better way&amp;rdquo; theme is shared from different communities&lt;/li&gt;
&lt;li&gt;Ringing endorsements from &lt;a href=&#34;https://pragprog.com/book/elixir/programming-elixir&#34; target=&#34;_blank&#34;&gt;other web influencers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course, I could be wrong&amp;hellip;Elixir could &lt;em&gt;not&lt;/em&gt; be the solution I&amp;rsquo;m looking for.  However, I do
know that I &lt;del&gt;want&lt;/del&gt; need a new way of building web applications and microservices. Here, I&amp;rsquo;d like to
do a series of posts about exploring and learning Elixir from the perspective of a Python
developer.&lt;/p&gt;

&lt;h2 id=&#34;elixir-for-pythonistas&#34;&gt;Elixir for Pythonistas&lt;/h2&gt;

&lt;p&gt;I would rather not do a series on Elixir syntax, but it&amp;rsquo;s inevitable that I&amp;rsquo;ll need to cover some
things.  There are plenty of resources online about Elixir syntax&amp;hellip;the official docs are quite
good. I&amp;rsquo;ll recommend the following if you&amp;rsquo;d like to start from zero:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://elixir-lang.org/crash-course.html&#34; target=&#34;_blank&#34;&gt;http://elixir-lang.org/crash-course.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;My &lt;a href=&#34;https://speakerdeck.com/brianz/elixir-fundamentals&#34; target=&#34;_blank&#34;&gt;Elixir Fundamentals talk from the Boulder Exile
Meetup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pragprog.com/book/elixir/programming-elixir&#34; target=&#34;_blank&#34;&gt;Programming Elixir by Dave Thomas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Very quickly I&amp;rsquo;d like to get rolling into the distributed nature of Elixir/Erlang, which I currently
don&amp;rsquo;t know many details about. Let&amp;rsquo;s start with some basics.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: I will say things like, &amp;ldquo;unlike Python&amp;hellip;&amp;rdquo; due to the fact that I&amp;rsquo;m writing from the
Pythonistas perspective. In reality, these comparisons should be made with procedural or OO
languages. Here, I&amp;rsquo;ll just use Python to represent that class of languages unless I&amp;rsquo;m discussing
something truly unique to Python.&lt;/p&gt;

&lt;h2 id=&#34;immutability-and-variables&#34;&gt;Immutability and Variables&lt;/h2&gt;

&lt;p&gt;Unlike Python, variables are immutable.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d = {&#39;name&#39;: &#39;bz&#39;, &#39;height&#39;: 67}
&amp;gt;&amp;gt;&amp;gt; some_function(d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, what is the value of &lt;code&gt;d&lt;/code&gt; without knowing the details of &lt;code&gt;some_function&lt;/code&gt;? It&amp;rsquo;s impossible to
answer this. The reason is that you&amp;rsquo;re passing the &lt;code&gt;d&lt;/code&gt; dictionary &lt;em&gt;by reference&lt;/em&gt;, which means
&lt;code&gt;some_function&lt;/code&gt; can mutate any mutable object it&amp;rsquo;s given (lists, sets, class, instances, etc.)&lt;/p&gt;

&lt;p&gt;What about Elixir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; d = %{name: &amp;quot;brian&amp;quot;, height: 67}
%{height: 67, name: &amp;quot;brian&amp;quot;}    
iex&amp;gt; some_function.(d)
%{height: 67, name: &amp;quot;Fred&amp;quot;}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll notice that the Elixir shell spits out values while it&amp;rsquo;s evaluating commands. Here, we can
see that &lt;code&gt;some_function&lt;/code&gt; is replacing the &lt;code&gt;name&lt;/code&gt; key with &lt;code&gt;&amp;quot;Fred&amp;quot;&lt;/code&gt;. But, look at &lt;code&gt;d&lt;/code&gt; after all of
this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; d
%{height: 67, name: &amp;quot;brian&amp;quot;} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s right&amp;hellip;our original map (&lt;code&gt;dict&lt;/code&gt; in Python terms) is unchanged. That&amp;rsquo;s pretty great. All of
a sudden it become &lt;em&gt;much&lt;/em&gt; easier to reason about what your program is doing since we&amp;rsquo;re dealing
with &lt;em&gt;data&lt;/em&gt; rather than &lt;em&gt;behavior&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;So, if we really did want to update our map, how would we handle this? We&amp;rsquo;ll simply &lt;em&gt;reassign&lt;/em&gt; the
&lt;code&gt;d&lt;/code&gt; variable to the &lt;em&gt;results&lt;/em&gt; returned from &lt;code&gt;some_function&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; d = some_function.(d)                                                     â”‚:yes
%{height: 67, name: &amp;quot;Fred&amp;quot;}
iex&amp;gt; d
%{height: 67, name: &amp;quot;Fred&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s just try to manhandle this thing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; Map.put(d, :name, &amp;quot;sam&amp;quot;)
%{height: 67, name: &amp;quot;sam&amp;quot;}  
iex&amp;gt; d
%{height: 67, name: &amp;quot;Fred&amp;quot;}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doh! You cannot mutate an existing object. You will always be &lt;em&gt;creating new&lt;/em&gt; objects. What you do
with those is up to you.&lt;/p&gt;

&lt;p&gt;I like this very much. Tracing code is now a matter of looking at what is occurring to the data,
rather than trying to track down what code is changing this class instance, dict, etc from under me.
There are other implications and advantages to immutable data types I won&amp;rsquo;t cover here.&lt;/p&gt;

&lt;h2 id=&#34;pattern-matching&#34;&gt;Pattern matching&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll hear the term &amp;ldquo;pattern matching&amp;rdquo; a lot with Elixir (and I&amp;rsquo;d guess, with Erlang). This will
likely be the biggest shift in thinking when coming from Python to Elixir, but I think it&amp;rsquo;s easy to
understand as you work with it.&lt;/p&gt;

&lt;p&gt;Above, we seemingly assigned a map to a variable &lt;code&gt;d&lt;/code&gt;. Don&amp;rsquo;t be fooled here&amp;hellip;what we did was
pattern match the left side of the equality operator with the right side. What does that mean
exactly?&lt;/p&gt;

&lt;p&gt;Elixir will take an expression and attempt to match whatever is on the left side of the equals sign
with that is on the right side, in this case, what is happening is that Elixir is matching the
variable &lt;code&gt;d&lt;/code&gt; with the map on the right:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; d = %{name: &amp;quot;brian&amp;quot;, height: 67}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is one item on the left, &lt;code&gt;d&lt;/code&gt; and one on the right, &lt;code&gt;%{name: &amp;quot;brian&amp;quot;, height: 67}&lt;/code&gt;&amp;hellip;so &lt;code&gt;d&lt;/code&gt;
ends up being pointed at this map.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look an Elixir tuple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; tup = {1, 2, 3}
{1, 2, 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Makes sense.  But we can also do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; {a, b, c} = {1, 2, 3}
{1, 2, 3}
iex&amp;gt; a
1
iex&amp;gt; b
2
iex&amp;gt; c
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is happening here is that Elixir attempt to match the left and right side. Because we have the
same number of arguments, the right side values are assigned to the left side variables. This is
&amp;ldquo;unpacking&amp;rdquo; in Python&amp;hellip;we can do the same thing so you may not be very impressed (yet):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; tup = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; (a, b, c) = tup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going back to our Map / dict, how would you extract the value of a dictionary key and assign it
into a variable?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; d
{&#39;name&#39;: &#39;bz&#39;, &#39;height&#39;: 67}
&amp;gt;&amp;gt;&amp;gt; myheight = d.get(&#39;height&#39;)
&amp;gt;&amp;gt;&amp;gt; myheight
67
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Elixir, we can extract a value by matching a key on the left with the right:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex&amp;gt; %{height: myheight} = d
%{height: 67, name: &amp;quot;Fred&amp;quot;}
iex&amp;gt; myheight
67
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow&amp;hellip;so we&amp;rsquo;re saying, &amp;ldquo;Elixir, please match a Map with a key of &amp;ldquo;height&amp;rdquo; on the left with whatever
is on the right. If that matches, assign the variable &lt;code&gt;myheight&lt;/code&gt; to whatever the value is on the
right side&amp;rdquo;&lt;/p&gt;

&lt;p&gt;That may seem trivial now, but it&amp;rsquo;s the underpinning of Elixir and helps preventing code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def view_function(request, user, reports=None):
    reports = reports or {}
    for key, f in reports.items():
        perm_key = &#39;user.can_view_%s_report&#39; % key 
        if key == &#39;unsigned&#39; and not user.sig_on:
            continue
        if key in (&#39;foo&#39;, &#39;br&#39;) and not user.new_user:
            continue
        if key in (&#39;payments&#39;, &#39;all&#39;, &#39;client&#39;) and not user.track:
            continue
        if key == &#39;authorizations&#39; and not user.cms_user:
            continue
        if key == &#39;totalcostof&#39; and not user.is_foobar:
            continue
        if key == &#39;premiums&#39; and not \
                (user.some_attribute and request.user.admin and request.user.admin.is_manager):
            continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Elixir, all of these conditionals could be handled with pattern matching, resulting in multiple functions
that handle some specific part of our domain logic. The code above becomes very very hard to reason
about, test and debug. Sure, this can be refactored, but to my previous points because it&amp;rsquo;s
&lt;em&gt;possible&lt;/em&gt; to write code like this, it&amp;rsquo;s inevitable that people will.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s it for now. I hope to continue on this path of exploring Elixir and writing about the
highlights I find interesting.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Authoring Alexa Skills with Python and Lazysusan</title>
      <link>http://blog.brianz.bz/post/alexa-with-lazysusan/</link>
      <pubDate>Tue, 24 Jan 2017 13:05:21 -0700</pubDate>
      
      <guid>http://blog.brianz.bz/post/alexa-with-lazysusan/</guid>
      <description>

&lt;p&gt;Most recently at my &lt;a href=&#34;http://joinspartan.com&#34; target=&#34;_blank&#34;&gt;day job&lt;/a&gt; we were tasked with building an Amazon Alexa
app for a client. As soon as I heard rumors that we would be doing an Alexa app I starting raising
my hand hoping that I&amp;rsquo;d get put on this project.  If you read these blog posts it should become
quite apparent I&amp;rsquo;m a pretty big AWS fanboy and Alexa has &lt;a href=&#34;https://aws.amazon.com/about-aws/whats-new/2015/06/create-new-voice-driven-capabilities-for-alexa-with-aws-lambda/&#34; target=&#34;_blank&#34;&gt;pretty tight integration with AWS
Lambda&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;alexa-overview&#34;&gt;Alexa overview&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re completely unfamiliar with Alexa it&amp;rsquo;s really quite simple from a both layperson&amp;rsquo;s and
technical perspective.&lt;/p&gt;

&lt;p&gt;Alexa is the voice platform behind the Amazon Echo, Dot and other Amazon speech devices. Regardless
of the Amazon device you&amp;rsquo;re interacting with via speech, it all goes through the &amp;ldquo;Alexa&amp;rdquo; platform
(as far as I know).&lt;/p&gt;

&lt;p&gt;From a developer&amp;rsquo;s perspective building Alexa apps is really really easy. Alexa apps send &lt;code&gt;json&lt;/code&gt;
to a given endpoint and expect valid Alexa &lt;code&gt;json&lt;/code&gt; in response. That&amp;rsquo;s it. Of course, there are many
nuances and details to understand, but from a high level this is it&amp;hellip;&lt;code&gt;json&lt;/code&gt; in and &lt;code&gt;json&lt;/code&gt; out.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: You&amp;rsquo;ll notice I said that &lt;code&gt;json&lt;/code&gt; is sent to an &amp;ldquo;endpoint&amp;rdquo;. With Alexa applications, you
have two choices for what that endpoint may be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A regular ol&amp;rsquo; https webserver&lt;/li&gt;
&lt;li&gt;A Lambda function&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I see absolutely zero advantages to deploying an Alexa application (officially known as &amp;ldquo;Alexa
Skills&amp;rdquo;) on your own https server. There are many things you&amp;rsquo;ll need to worry about&amp;hellip;ssl certs,
scaling, high availability, monitoring&amp;hellip;etc. Basically, all of the things any good SAAS
application developer would worry about when deploying a new system.&lt;/p&gt;

&lt;p&gt;Due to the seamless integration with Lambda, it&amp;rsquo;s going to be the right decision 99% of
the time when building Alexa Skills.&lt;/p&gt;

&lt;p&gt;The only way I would suggest running your own server to back Alexa Skills is if your application
code had some pretty heavy dependencies such as &lt;code&gt;numpy&lt;/code&gt; or another big and heavy requirement which
couldn&amp;rsquo;t fit inside a Lambda function. Since Lambda support Python and Node out of the box, those
will likely be your two choices for implementation languages/ecosystems. If you&amp;rsquo;re a real masochist
you can run Java on Lambda. C# was recently released as a supported language as well.&lt;/p&gt;

&lt;h2 id=&#34;lazysusan&#34;&gt;Lazysusan&lt;/h2&gt;

&lt;p&gt;During our client engagement we would up authoring an open source Python library for authoring
Alexa applications. We call her &lt;a href=&#34;https://github.com/spartansystems/lazysusan&#34; target=&#34;_blank&#34;&gt;Lazysusan&lt;/a&gt;. I&amp;rsquo;ll walk
you through all of the steps in authoring a very very basic Alexa Skill.&lt;/p&gt;

&lt;p&gt;I find that Python strikes a really nice balance in terms of readability, capabilities and extensibility
for Lambda functions. There is an existing &lt;code&gt;npm&lt;/code&gt; module for Alexa skills from the Amazon teams. We
opted to write our own in Python for the main reason that we found Python to be a much nicer and
easier language to work with.&lt;/p&gt;

&lt;h2 id=&#34;lazysusan-concept-s&#34;&gt;Lazysusan concept(s)&lt;/h2&gt;

&lt;p&gt;Lazysusan has one big concept which is critical to understanding how to build your own skill&amp;hellip;that
is, application state.&lt;/p&gt;

&lt;p&gt;Lazysusan handles Alexa requests with the current logic/flow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Look up current state&lt;/li&gt;
&lt;li&gt;Given the current state and the user&amp;rsquo;s intent, find what the response should be&lt;/li&gt;
&lt;li&gt;If no response can be found for user&amp;rsquo;s intent given the current state, fallback to the &lt;code&gt;default&lt;/code&gt;
response&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition to this flow of logic there are a couple of concepts to understand, notably &amp;ldquo;intent&amp;rdquo;
and &amp;ldquo;state&amp;rdquo;. We&amp;rsquo;ll drill into these concepts below. For now, let&amp;rsquo;s look at this flow of Lazysusan
logic as a graphic:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.brianz.bz/images/lazysusan/logic-flow.png&#34; height=&#34;600&#34; align=&#34;middle&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;example-application&#34;&gt;Example application&lt;/h2&gt;

&lt;p&gt;We have an example application in the Lazysusan repository. Have a look at:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spartansystems/lazysusan/tree/master/examples/age_difference&#34; target=&#34;_blank&#34;&gt;https://github.com/spartansystems/lazysusan/tree/master/examples/age_difference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll walk through it fun little Alexa skill and explain how it&amp;rsquo;s built with Lazysusan.&lt;/p&gt;

&lt;h2 id=&#34;state-definition-and-flow&#34;&gt;State definition and flow&lt;/h2&gt;

&lt;p&gt;The key in any Lazysusan app is a yaml file which definite each response and how to handle requests
from a given state. Remember, when a request comes in Lazysusan will figure out two things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;What state is the user at?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Given this state and their intent, how should I responds?&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a very simple example of a &lt;code&gt;state.yml&lt;/code&gt; file lifted from our Age Calculator example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;initialState:
  response:
    card:
      type: Simple
      title: Age Difference
      content: &amp;gt;
        When is your birthday?
    outputSpeech:
      type: PlainText
      text: &amp;gt;
        When is your birthday?
    shouldEndSession: False
  branches: &amp;amp;initialStateBranches
    LaunchRequest: initialState
    MyAgeIntent: !!python/name:callbacks.calc_difference
    default: goodBye

missingYear:
  response:
    outputSpeech:
      type: PlainText
      text: Please say what day, month and year you were born.
    shouldEndSession: True
  branches:
    &amp;lt;&amp;lt;: *initialStateBranches
    LaunchRequest: initialState

goodBye:
  response:
    outputSpeech:
      type: PlainText
      text: &amp;gt;
        Thanks for trying age difference, good bye.
    shouldEndSession: True
  branches:
    &amp;lt;&amp;lt;: *initialStateBranches
    LaunchRequest: initialState
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &amp;ldquo;session&amp;rdquo; in Alexa parlance can be a bit nebulous. By default, when a user launches your skill and
begins interacting it there is a built-in session which is active.  This &amp;ldquo;session&amp;rdquo; is nothing more
than some data sent to your Lambda function in the &lt;code&gt;json&lt;/code&gt; payload.
As long as the user is
interacting with your skill and the blue light ring on top of the device is illuminated, the
session is active. If the user doesn&amp;rsquo;t respond at all or reaches the &amp;ldquo;end&amp;rdquo; of the skill, the
session will be killed.&lt;/p&gt;

&lt;p&gt;Think of an Alexa session as a conversation with a real person&amp;hellip;provided you keep the
conversation going, the session is active.  Now imagine during a real conversation you simply walk
out the door leaving your conversational partner standing there alone. Your conversation has ended
and the session is now over. Or, imagine the other party in the conversation bluntly ends the
chat&amp;hellip;&amp;ldquo;I&amp;rsquo;m sorry, but I have to go. Goodbye&amp;rdquo;. This is exactly how a session may end with Alexa.
You may simple decide you&amp;rsquo;re done and not reply or the other party may call it quits.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s define &lt;code&gt;state&lt;/code&gt; is in Lazysusan parlance.  State is nothing more than a current location
in your Alexa Skill &amp;ldquo;flow&amp;rdquo;. In concrete terms, &amp;ldquo;state&amp;rdquo; will simple be the name of the top-level
keys in your &lt;code&gt;states.yml&lt;/code&gt; file. In our example above there are three possible states:
&lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;missingYear&lt;/code&gt; and &lt;code&gt;goodBye&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In our example, we&amp;rsquo;ll ask a simple question to the user and provide a (somewhat) simple response
given their input intent:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User: &amp;ldquo;Open age calculator&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Alexa: &amp;ldquo;When is your birthday?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;U: Jan 12, 1972&lt;/li&gt;
&lt;li&gt;A: &amp;ldquo;You are 45 years, 11 days old, &amp;hellip;.&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;intents&#34;&gt;Intents&lt;/h3&gt;

&lt;p&gt;I will keep the explanation of &amp;ldquo;intent&amp;rdquo; brief since there is &lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/alexa-skills-kit-interaction-model-reference&#34; target=&#34;_blank&#34;&gt;lots of documentation about it on the
Alexa developer
site&lt;/a&gt;.
For this post it&amp;rsquo;s still important to understand it from a high level.&lt;/p&gt;

&lt;p&gt;When defining the interaction model of your Alexa Skill in the Alexa developer portal  you will map
natural language phrases to intents. For example, &amp;ldquo;My phone number if 555-1212&amp;rdquo; may map to
something you define as &lt;code&gt;MyPhoneNumberIntent&lt;/code&gt;.  Your Alexa skill will receive a &lt;code&gt;json&lt;/code&gt; payload that
literally has the &lt;code&gt;MyPhoneNumberIntent&lt;/code&gt; string included in it.  Given you know what the user&amp;rsquo;s
intent is, you can make some decisions via application code on how to respond.&lt;/p&gt;

&lt;p&gt;Of course there are many details around using and defining intents so I&amp;rsquo;d encourage you to read the
Amazon docs for more information.&lt;/p&gt;

&lt;h3 id=&#34;initial-state&#34;&gt;Initial state&lt;/h3&gt;

&lt;p&gt;Upon the first request, there is no session to speak of. In that scenario, Lazysusan will look for
a key in your yaml file named &lt;code&gt;initialState&lt;/code&gt;.  Alexa apps are often launched with a phrase which will
trigger a &lt;code&gt;LaunchRequest&lt;/code&gt;. This is exactly what we&amp;rsquo;ve done here with the phrase, &lt;code&gt;Open age
calculator&lt;/code&gt;.  So, we are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In &lt;code&gt;initialState&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Receiving a &lt;code&gt;LaunchRequest&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With those to pieces of information, Lazysusan will look up the &lt;code&gt;LaunchRequest&lt;/code&gt; key in the list of
&lt;code&gt;branches&lt;/code&gt; in the &lt;code&gt;initialState&lt;/code&gt; block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;initialState:
  # snip
  branches: &amp;amp;initialStateBranches
    LaunchRequest: initialState
    MyAgeIntent: !!python/name:callbacks.calc_difference
    default: goodBye
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see in the yaml above, &lt;code&gt;LaunchRequest&lt;/code&gt; simply points back
to the &lt;code&gt;initialState&lt;/code&gt; block which contains a fully valid Alexa response in yaml.  Lazysusan will
take this content verbatim, convert it into json and sent it back to Alexa.&lt;/p&gt;

&lt;h3 id=&#34;response-after-initial-state&#34;&gt;Response after initial state&lt;/h3&gt;

&lt;p&gt;The user has received a question, responded and the session is still active. What happens next?
The user responded with a date which triggers a &lt;code&gt;MyAgeIntent&lt;/code&gt; from the Alexa platform. So, we are now:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In &lt;code&gt;initialState&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Receiving a &lt;code&gt;MyAgeIntent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With those to pieces of information, Lazysusan will look up the &lt;code&gt;MyAgeIntent&lt;/code&gt; key the list of
&lt;code&gt;branches&lt;/code&gt; in the &lt;code&gt;initialState&lt;/code&gt; block. Looking at the &lt;code&gt;branches&lt;/code&gt; list above we can see how
Lazysusan will determine the response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    MyAgeIntent: !!python/name:callbacks.calc_difference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a magical little part of the &lt;a href=&#34;http://pyyaml.org/wiki/PyYAMLDocumentation&#34; target=&#34;_blank&#34;&gt;PyYAML&lt;/a&gt; package.
Here, &lt;code&gt;MyAgeIntent&lt;/code&gt; is literally pointing to a Python function. If Lazysusan encounters a callable
object/function in &lt;code&gt;states.yml&lt;/code&gt; it will call that function with six arguments (you can see those
arguments &lt;a href=&#34;https://github.com/spartansystems/lazysusan/blob/master/lazysusan/app.py#L70&#34; target=&#34;_blank&#34;&gt;in the &lt;code&gt;app.py&lt;/code&gt;
file&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;For the
purposes of this blog post, it&amp;rsquo;s not super critical to understand all the permutations or arguments
passed into a callback&amp;hellip;what is important is knowing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you can build completely 100% dynamic responses using this callback mechanism&lt;/li&gt;
&lt;li&gt;you can return either :

&lt;ul&gt;
&lt;li&gt;the name of the next response key as a string which will be looked up in &lt;code&gt;states.yml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;an actual response using &lt;code&gt;helpers/build_response&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you look at the source code for this example, we are doing a bunch of fancy date math (made
harder due to leap years, of course) and returning a response with a helper function appropriately
called, &lt;code&gt;build_response&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;walking-through-a-callback&#34;&gt;Walking through a callback&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the callback function which Lazysusan invokes when a &lt;code&gt;MyAgeIntent&lt;/code&gt; is
encountered during an Alexa request:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def calc_difference(**kwargs):
    request = kwargs[&amp;quot;request&amp;quot;]
    session = kwargs[&amp;quot;session&amp;quot;]
    state_machine = kwargs[&amp;quot;state_machine&amp;quot;]
    log = get_logger()

    date_string = request.get_slot_value(&amp;quot;dob&amp;quot;)
    if not date_string:
        log.error(&amp;quot;Could not find date in slots&amp;quot;)
        return &amp;quot;goodBye&amp;quot;

    if date_string.startswith(&#39;XXXX-&#39;):
        return &amp;quot;missingYear&amp;quot;

    now = datetime.now()

    dob = get_dob_from_date_string(date_string)
    if not is_valid_day(dob):
        return &amp;quot;invalidDate&amp;quot;

    age = get_age_from_dob(dob, now)

    # First get a breakdown of how old user is in years, months, days
    msg = age_breakdown(age)

    # next figure out the days until the users next birthday
    msg += &amp;quot;%s&amp;quot; % (days_until_birthday(dob, now), )

    # finally add whether we&#39;re older or younger than the last user
    msg += &amp;quot;%s&amp;quot; % (last_user_difference(session, dob), )

    session.set(DOB_KEY, dob.toordinal())

    response_dict = build_response(&amp;quot;ageResponse&amp;quot;, msg, state_machine)
    return build_response_payload(response_dict, session.get_state_params())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We won&amp;rsquo;t go through every line, but a few things worth noting:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There are currently six &lt;code&gt;kwargs&lt;/code&gt; which are passed into a callback from Lazysusan. Here, we really
only care about three of those and get them out of the &lt;code&gt;kwargs&lt;/code&gt; dictionary.&lt;/li&gt;
&lt;li&gt;You&amp;rsquo;ll notice three different places where some error checking is performed. If the error
condition in triggered you&amp;rsquo;ll see some return statements, such as:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if date_string.startswith(&#39;XXXX-&#39;):
    return &amp;quot;missingYear&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a string is returned from a callback, Lazysusan assumes this is a key to a response in
&lt;code&gt;states.yml&lt;/code&gt;. If the error above was triggered the response would be synthesized from the
&lt;code&gt;missingYear&lt;/code&gt; text above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;text: Please say what day, month and year you were born.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a reminder, the structure of yaml file for responses is completely driven by the required format
for an alexa response. There is zero translation / mutation done by Lazysusan&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One of the objects you have access to is a &lt;code&gt;session&lt;/code&gt; object. In the call to &lt;code&gt;session.set&lt;/code&gt; above we
are shoving a value into the session for the &lt;code&gt;DOB_KEY&lt;/code&gt; value. You may use the session however you
see fit&amp;hellip;it&amp;rsquo;s simply a key-value store provided for your use.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;deployment-and-management&#34;&gt;Deployment and management&lt;/h2&gt;

&lt;p&gt;It may come as no big surprise that we opted to use &lt;a href=&#34;https://serverless.com&#34; target=&#34;_blank&#34;&gt;Serverless&lt;/a&gt; for
managing out Lambda functions and other dependencies. This ended up being a really great choice
since Serverless will manage not only your Lambda functions but anything else that  is supported by
CloudFormation (which is almost everything).&lt;/p&gt;

&lt;p&gt;During our client engagement an &lt;code&gt;sls deploy&lt;/code&gt; would create, update or manage:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cloudwatch alarms for DynamoDB&lt;/li&gt;
&lt;li&gt;Cloudwatch alarms for Lambda function&lt;/li&gt;
&lt;li&gt;DynamoDB table&lt;/li&gt;
&lt;li&gt;DynamoDB table IOPs provisioning&lt;/li&gt;
&lt;li&gt;IAM roles for DynamoDB table access&lt;/li&gt;
&lt;li&gt;Lambda function for Alexa&lt;/li&gt;
&lt;li&gt;SNS topic&lt;/li&gt;
&lt;li&gt;SNS topic subscriptions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As of this writing managing Alexa Skills isn&amp;rsquo;t nearly as easy.  The only way to manage your
interaction model and overall configuration is to fire up developer.amazon.com and plug things in
manually.  I know that Amazon is working on driving configuration of Alexa Skills programatically
but it&amp;rsquo;s currently not there.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve published a Docker image which has all of the requirement for writing Lazysusan applications
and managing them with Serverless:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/joinspartan/serverless/&#34; target=&#34;_blank&#34;&gt;https://hub.docker.com/r/joinspartan/serverless/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;final-results&#34;&gt;Final results&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s a little recording of the demo skill.  As you can hear, there are a lot of calculated valued
returned from the user&amp;rsquo;s input. This shows the flexibility of the callback mechanism we&amp;rsquo;ve
implemented.&lt;/p&gt;

&lt;p&gt;&lt;audio controls src=&#34;http://blog.brianz.bz/audio/age-calculator.mp3&#34; type=&#34;audio/mpeg&#34;&gt;
Your user agent does not support the HTML5 Audio element.
&lt;/audio&gt;&lt;/p&gt;

&lt;p&gt;Lazysusan provides other options to make building Alexa skills easier and more sophisticated
including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pluggable support for using DynamoDB as a session store. This enables sessions to persist for
longer than the standard eight seconds&lt;/li&gt;
&lt;li&gt;TTL support for sessions when using DynamoDB as a session store&lt;/li&gt;
&lt;li&gt;Support for restarting audio from the last stopped/paused position&lt;/li&gt;
&lt;li&gt;Marking a location in &lt;code&gt;states.yml&lt;/code&gt; as &lt;strong&gt;not&lt;/strong&gt; being a state to track. This is critical when
receiving callbacks from Alexa during audio playback.&lt;/li&gt;
&lt;li&gt;Configurable logging levels to see request/responses in Cloudwatch&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Lazysusan makes building Alexa apps really really simple. In a future post I&amp;rsquo;ll drill into some
more detail around the apis and things you may need to be aware of.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve developed a few example applications which can be found &lt;a href=&#34;https://github.com/spartansystems/lazysusan/tree/master/examples&#34; target=&#34;_blank&#34;&gt;in the examples directory in our
Github repository&lt;/a&gt;. These are
great places to start exploring if you&amp;rsquo;d like to take Lazysusan for a spin or have a better
understanding of what the application code looks like.  These examples show a somewhat complex
skill such as the age calculator and some others which are driven almost exclusively from the
&lt;code&gt;states.yml&lt;/code&gt; file with very very little Python code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Demo service with Servant</title>
      <link>http://blog.brianz.bz/post/demo-service-with-servant/</link>
      <pubDate>Thu, 15 Sep 2016 17:41:39 -0400</pubDate>
      
      <guid>http://blog.brianz.bz/post/demo-service-with-servant/</guid>
      <description>

&lt;p&gt;In a &lt;a href=&#34;http://blog.brianz.bz/post/introducing-servant/&#34;&gt;previous post&lt;/a&gt; I introduced and discussed
about an open source library I authored called Servant. Servant is a framework for building
RPC-style services with Python. Servant is to services as Django or Rails is to web
applications&amp;hellip;it&amp;rsquo;s framework you&amp;rsquo;d use when you need to build a service in Python.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll go a bit deeper in this post and show what it&amp;rsquo;s like to actually author and use a service.
Let&amp;rsquo;s first start by writing the service.  To save some time we&amp;rsquo;ll take a look at the &lt;a
href=&#34;https://github.com/brianz/servant/tree/master/examples/calculator_service&#34;&gt;&lt;code&gt;calculator_service&lt;/code&gt;&lt;/a&gt;
which is in the &lt;code&gt;examples&lt;/code&gt; directory in the Servant repository.&lt;/p&gt;

&lt;h2 id=&#34;writing-the-service&#34;&gt;Writing the service&lt;/h2&gt;

&lt;h3 id=&#34;boilerplate&#34;&gt;Boilerplate&lt;/h3&gt;

&lt;p&gt;There are a few requirements to write a service.  I&amp;rsquo;ll start with the boring parts which is mostly
boilerplate to get your service setup as an install-able Python package. I also suggest looking at
the directory structure for the demo &lt;code&gt;calculator_service&lt;/code&gt; on Github:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/brianz/servant/tree/master/examples/calculator_service&#34; target=&#34;_blank&#34;&gt;https://github.com/brianz/servant/tree/master/examples/calculator_service&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;At a bare minimum you&amp;rsquo;ll need a &lt;code&gt;setup.py&lt;/code&gt; file and a directory with the correct name.  In this
example, the name is &lt;code&gt;calculator_service&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/eab945699d396a5656e355e8f1264562.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;From there you&amp;rsquo;ll also need a directory where your source code will live.&lt;/p&gt;

&lt;h3 id=&#34;service&#34;&gt;Service&lt;/h3&gt;

&lt;p&gt;Every Servant service needs an entry-point to device the endpoints which will be exposed. This is
pretty simple&amp;hellip;create a file names &lt;code&gt;service.py&lt;/code&gt; which contains a class that subclasses
&lt;code&gt;servant.service.base.Service&lt;/code&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/7addb2cf37a6cadda3d15fd6c623bf21.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Your service class will only need a few things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; attribute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;version&lt;/code&gt; attribute (use &lt;code&gt;1&lt;/code&gt; when getting started)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;action_map&lt;/code&gt; which is a dictionary mapping endpoint name to an &lt;code&gt;Action&lt;/code&gt; class&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;rsquo;s really it&amp;hellip;of course there are more things you can do in your service class to handle
configuration, etc. However, this is the minimum amount of work you&amp;rsquo;ll need to do in order to get
started.&lt;/p&gt;

&lt;p&gt;In our example you can see our &lt;code&gt;calculator_service&lt;/code&gt; exposed three calculate endpoints&amp;hellip;&lt;code&gt;add&lt;/code&gt;,
&lt;code&gt;subtract&lt;/code&gt; and &lt;code&gt;divide&lt;/code&gt;.  These will do what you&amp;rsquo;d expect.&lt;/p&gt;

&lt;h3 id=&#34;actions&#34;&gt;Actions&lt;/h3&gt;

&lt;p&gt;An &lt;code&gt;Action&lt;/code&gt; is really the meat and potatoes for a particular endpoint. You can organize your
actions however you like&amp;hellip;one action per file, multiple actions per file, etc.  Since we&amp;rsquo;re
writing a pretty simple service and only have three actions, we&amp;rsquo;ll put them all in &lt;code&gt;actions.py&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/91b2a58709d569443aab5b98aaa38e0b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Let&amp;rsquo;s walk through what it takes to implement a single action (or, an &amp;ldquo;endpoint&amp;rdquo; from the client&amp;rsquo;s
perspective).  Looking at &lt;code&gt;AddAction&lt;/code&gt; we can see that there are two required inputs&amp;hellip;&lt;code&gt;number1&lt;/code&gt; and
&lt;code&gt;number2&lt;/code&gt;. I liken the structure of a servant &lt;code&gt;Action&lt;/code&gt; to a Django, SQLAlchemy or other type of
model.  You&amp;rsquo;ll need to subclass &lt;code&gt;servant.service.actions.Action&lt;/code&gt; and usually define one or more
inputs as class attributes which are servant &lt;code&gt;field&lt;/code&gt; types.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;AddAction&lt;/code&gt; we ensure that the client passes us &lt;code&gt;number1&lt;/code&gt; and &lt;code&gt;number2&lt;/code&gt; by adding
&lt;code&gt;required=True&lt;/code&gt; to the field&amp;rsquo;s kwargs. This instructs servant to return an error in the case that
the client doesn&amp;rsquo;t pass either of these. Out of the box we get some error checking for free which
is quite nice.  From there it&amp;rsquo;s also your responsibility as the developer to device the return type
which the client will get back after a successful call.  Here, we&amp;rsquo;ll return a single integer using
an &lt;code&gt;IntField&lt;/code&gt; field type which is named &lt;code&gt;result&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your entry point into an action is the &lt;code&gt;run&lt;/code&gt; method.  You can see above what it does&amp;hellip;it&amp;rsquo;s simple
one-liner.  By the time your &lt;code&gt;run&lt;/code&gt; method is being executed the basic error checking has completed
and all of the required and optional fields will be available to you as class attributes.  So, our
&lt;code&gt;run&lt;/code&gt; method simple sets the result using the two inputs we received from the client:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def run(self, **kwargs):
    self.result = self.number1 + self.number2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; method doesn&amp;rsquo;t need to return anything&amp;hellip;all return data is handled via the field
attributes.&lt;/p&gt;

&lt;p&gt;If you read the rest of the gist above you can see how the subtract and divide actions are
implemented. Being a calculator, there really isn&amp;rsquo;t much to it.  You&amp;rsquo;ll notice that the subtract
action subclassed the add action and just overrides the &lt;code&gt;run&lt;/code&gt; method.  The &lt;code&gt;divide&lt;/code&gt; action mostly
just changes the names of the inputs and output.&lt;/p&gt;

&lt;h2 id=&#34;using-the-service&#34;&gt;Using the service&lt;/h2&gt;

&lt;p&gt;One neat feature of Servant is the ability to run your service as a locally installed Python
library.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s install both Servant and the calculator service into a new virtualenv:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd path/to/servant
$ mkvirtualenv calculator_service
$ pip install -e .
$ cd examples/calculator_service
$ pip install -e .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have these installed, we can actually test our service!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import servant.client

client = servant.client.Client(&#39;calculator_service&#39;, version=1)

response = client.add(number1=10, number2=15)

if response.is_error():
    print response.errors, response.field_errors
else:
    print response.result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this, we get our expected result of &lt;code&gt;25&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, how do we run this on a separate host so that we&amp;rsquo;re actually a stand-alone service?  Quite
easy&amp;hellip;first we&amp;rsquo;ll setup a &lt;code&gt;wsgi&lt;/code&gt; server using &lt;code&gt;uwsgi&lt;/code&gt;. We need two files&amp;hellip;one is a 3-line python
file which is the entry-point for the service.  The other is a very short &lt;code&gt;uwsgi&lt;/code&gt; config file.
Servant has built-in support for running as a wsgi server so &lt;code&gt;wsgi_handler.py&lt;/code&gt; is quite short:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/f74825460c85c5b5f59255d644a2576a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Now, fire up uwsgi: &lt;code&gt;uwsgi uwsgi.ini&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;uwsgi is now ready to serve requests on port 8888&amp;hellip;we can run the &lt;em&gt;exact&lt;/em&gt; same client code as
above.  You&amp;rsquo;ll note that the client code above &lt;em&gt;only&lt;/em&gt; depends on the &lt;code&gt;servant&lt;/code&gt; library. Really, the
only reference to the &lt;code&gt;calculator_service&lt;/code&gt; is when we instantiate the &lt;code&gt;Client&lt;/code&gt; class.  There is
only one change we need to make to the client code above to hit a remote system:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;client.configure(&#39;http&#39;, host=&#39;192.168.88.100&#39;, port=8888)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re configuring our client to connect via &lt;code&gt;http&lt;/code&gt; to the given host and port.  Once that single
line is added we can run the client and get the exact same results.&lt;/p&gt;

&lt;p&gt;I believe the power of being able to develop a service and run it locally like this and deploy it
remotely with only a single line changing for the client is immensely powerful. Admittedly, when
using Docker standing up a server is pretty easy, but being able to run service code without
depending on a server is still quite valuable. Another big advantage is that it&amp;rsquo;s possible to
actually pip install your service package with your client application and not depend on a remote
system staying up. The advantage is by pip installing a service is that you&amp;rsquo;re able to deploy a
service much faster and iterate simply by pip installing&amp;hellip;when it&amp;rsquo;s time to migrate it&amp;rsquo;s just a
matter of a minor change to your client code to point to the remote host.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing servant</title>
      <link>http://blog.brianz.bz/post/introducing-servant/</link>
      <pubDate>Mon, 04 Apr 2016 17:26:23 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/introducing-servant/</guid>
      <description>

&lt;p&gt;Late in 2014 we began the process of discussing a payment system at
&lt;a href=&#34;http://www.clearcareonline.com&#34; target=&#34;_blank&#34;&gt;work&lt;/a&gt;. The system was to have a fairly simple reason for
existing&amp;hellip;to do all the work needed to charge credit cards on behalf of our customers.&lt;/p&gt;

&lt;p&gt;Backing up a bit&amp;hellip;our system is mainly a B2B application. Home care agencies all over the country
run our SAAS application which helps them to run their businesses. Our new Payment System was aimed at allowing
our customers to charge &lt;em&gt;their&lt;/em&gt; customers&amp;rsquo; credit cards directly, meaning our customers don&amp;rsquo;t need
to wait for checks or paper invoicing. Our SAAS is a pretty typical Python stack with the &lt;strong&gt;major&lt;/strong&gt;
components being:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;monolithic Django app&lt;/li&gt;
&lt;li&gt;Postgres&lt;/li&gt;
&lt;li&gt;Elasticsearch&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Celery/RabbitMQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For us it was pretty clear that we wanted to build this as a stand-alone service and stick with
Python. Yeah&amp;hellip;we wanted a &lt;em&gt;microservice&lt;/em&gt; which is all the rage now. We knew that we needed to
start evolving our architecture and services, while having their own sets of challenges, make a lot
of sense. In late 2014 the issue was that there really wasn&amp;rsquo;t (and still aren&amp;rsquo;t) many existing and
proven frameworks for building services in Python.&lt;/p&gt;

&lt;h2 id=&#34;enter-servant&#34;&gt;Enter servant&lt;/h2&gt;

&lt;p&gt;Leaning on a custom service framework I had worked with while at
&lt;a href=&#34;http://eventbrite.com&#34; target=&#34;_blank&#34;&gt;Eventbrite&lt;/a&gt; I came up with servant. You can see the project page on Github.
We currently have multiple services deployed in production at Clearcare based on servant and so
far, they&amp;rsquo;ve been working great:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/clearcare/servant&#34; target=&#34;_blank&#34;&gt;https://github.com/clearcare/servant&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What exactly is this library? At a very high level servant is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a Python library/framework for authoring and communicating with services&lt;/li&gt;
&lt;li&gt;to services what Django/Flask/Rails are to web applications&lt;/li&gt;
&lt;li&gt;designed primarily for &lt;em&gt;internal&lt;/em&gt; non-publicly facing services&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Servant is actually pretty simple and doesn&amp;rsquo;t perform much magic.  What it does do
is give you, the service author, a framework for designing RPC-style services in Python which
can run on their own, independently, and are easy to connect to and interface with. In addition,
it&amp;rsquo;s not an opinionated framework so you can choose whatever tooling you&amp;rsquo;d like in order to author
your service. Our typical recipe at work includes pytest for testing and sqlalchemy for talking to
the Postgres. However, you use whatever you want depending on your needs&amp;hellip;servant stays out of
your way and deals with executing service calls on behalf of the client. There is some validation
here and there to ensure the service call is well-formed but I won&amp;rsquo;t go over that right now.&lt;/p&gt;

&lt;h2 id=&#34;quick-code-examples&#34;&gt;Quick code examples&lt;/h2&gt;

&lt;p&gt;When I first started using services I had no idea what looked like both authoring a service or
talking to a service. If you have never worked with a service framework you may think it&amp;rsquo;s a matter
of writing or talking to a REST endpoint. Servant is a bit different&amp;hellip;so here are a few small code
snippets which should make things more clear.&lt;/p&gt;

&lt;p&gt;In this example, we&amp;rsquo;ll create a silly little &amp;ldquo;Calculator Service&amp;rdquo;. I&amp;rsquo;ll implement an &lt;code&gt;add&lt;/code&gt; endpoint
which will take two numbers, add them up and return the sum.&lt;/p&gt;

&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;

&lt;p&gt;As a client, the only dependencies is having the servant library installed. You could call this
from a Django app, one-off script&amp;hellip;wherever. Install servant from github. Here I install it into a
virtualenv using virtualenvwrapper:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold$ mkvirtualenv test_servant

(test_servant)brianz@gold$ pip install git+https://github.com/clearcare/servant.git@master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, I can write some client code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# test_add.py
import servant.client

client = servant.client.Client(&#39;calculator_service&#39;, version=1)

# add is the actual endpoint we&#39;re calling
response = client.add(number1=10, number2=15)

if response.is_error():
    print response.errors, response.field_errors
else:
    print response.result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s about it for client code! Provided you have a service named &lt;code&gt;calculator_service&lt;/code&gt; available,
this code will work and spit out the expected result of &lt;code&gt;25&lt;/code&gt;. You can actually install
&lt;code&gt;calculator_service&lt;/code&gt; yourself and run this code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(test_servant)brianz@gold$ cd servant/examples/calculator_service/
(test_servant)brianz@gold$ pip install .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(test_servant)brianz@bz-cconline$ python test_calculator.py 
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s how you actually &lt;em&gt;use&lt;/em&gt; a servant service. How do you author one?&lt;/p&gt;

&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;

&lt;p&gt;Authoring a service is a bit more work but still quite easy. This is how you&amp;rsquo;d implement the &lt;code&gt;add&lt;/code&gt;
method we used above. Note you can also &lt;a href=&#34;https://github.com/clearcare/servant/tree/master/examples/calculator_service&#34; target=&#34;_blank&#34;&gt;peruse the
&lt;code&gt;calculator_service&lt;/code&gt;&lt;/a&gt;
to see a more thorough implemenation..but the below code will actually work.&lt;/p&gt;

&lt;p&gt;First, you need to define a single &lt;code&gt;service.py&lt;/code&gt; file which defines your service and declares all
its endpoints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# service.py
from servant.service.base import Service

import actions

class Calculator(Service):

    name = &#39;calculator_service&#39;
    version = 1 

    action_map = { 
            &#39;add&#39;: actions.AddAction,
            # we won&#39;t implement subtract now
            # &#39;subtract&#39;: actions.SubtractAction,
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, you&amp;rsquo;ll need to create one or more actions. Note above we import &lt;code&gt;actions&lt;/code&gt; and point to two
different action classes&amp;hellip;we&amp;rsquo;ll only show one here for brevity. But, how you map endpoint
names to actions is entirely up to you. We always have an &lt;code&gt;actions/&lt;/code&gt; directory with different
actions broken up by area of responsibility. Again, for brevity we&amp;rsquo;ll just show a single action for
our calculator service.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# actions.py
import servant.fields
from servant.service.actions import Action

class AddAction(Action):
    number1 = servant.fields.IntField(
            required=True,
            in_response=True,
    )   
    number2 = servant.fields.IntField(
            required=True,
            in_response=True,
    )   
    result = servant.fields.IntField(
            in_response=True,
    )   

    def run(self, **kwargs):
        self.result = self.number1 + self.number2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you ignore &lt;code&gt;setup.py&lt;/code&gt; and any other packaging code or files, our actual service is only a few
files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(test_servant)brianz@gold$ tree
â”œâ”€â”€ __init__.py
â”œâ”€â”€ actions.py
â””â”€â”€ service.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can imagine what &lt;code&gt;SubtractAction&lt;/code&gt; would look like. From there, provided you
can install your service as a Python package, this code is fully functional. You can see all of
this and actually give it a try&amp;hellip;clone the repo and look in
the &lt;a href=&#34;https://github.com/clearcare/servant/tree/master/examples/calculator_service&#34; target=&#34;_blank&#34;&gt;the examples directory&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;local-library-mode&#34;&gt;Local library mode&lt;/h2&gt;

&lt;p&gt;One killer feature IMO which I have only seen in Eventbrite&amp;rsquo;s SOA library is that of local mode.
You&amp;rsquo;ll notice in all of the code above, there is no mention or reference to where the service is
running. You didn&amp;rsquo;t event start a server. Where is the client connecting? How does the client code
know where to connect? What port is the server running on?&lt;/p&gt;

&lt;p&gt;When you author a service and are able to install it as a Python package, you can talk to it just
as if it were running on a remote system. The magic here is that the servant client code imports
your service and executes it as a local library.  When you&amp;rsquo;re ready to deploy your service
somewhere else and point your clients to the &lt;em&gt;real&lt;/em&gt; server, it&amp;rsquo;s a one line change:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import servant.client

client = servant.client.Client(&#39;calculator_service&#39;, version=1)
# Now point your client to the remote host
client.configure(&#39;remote-host-name-or-ip&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The big advantage to this is that it&amp;rsquo;s trivially easy to start developing and testing your service.
Unit testing is &lt;em&gt;really&lt;/em&gt; easy.  The code which gets executed is almost exactly the same. Of course,
running on a real server rather than as a local library cannot be &lt;em&gt;identical&lt;/em&gt;, but it&amp;rsquo;s quite close
and any differences are definitely worth the increase in productivity.&lt;/p&gt;

&lt;h2 id=&#34;why-servant&#34;&gt;Why servant?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;This is dumb, REST rules!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hey, we (mostly) all like REST&amp;hellip;it&amp;rsquo;s great, but has some limitations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP  by definition&lt;/li&gt;
&lt;li&gt;Requires a running server&lt;/li&gt;
&lt;li&gt;Usually end up using a wrapper library&lt;/li&gt;
&lt;li&gt;Various interpretations&lt;/li&gt;
&lt;li&gt;Can be challenging to get your Resources right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Being a RPC-style library, with servant:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Transport/broker can be anything (library call, HTTP, Redis, Ã˜MQ, RabbitMQ&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Develop quickly with local library mode&lt;/li&gt;
&lt;li&gt;RPC endpoints can be more descriptive&amp;hellip;no need to interpret PUT vs POST&lt;/li&gt;
&lt;li&gt;ONE way of implementing a service vs. author&amp;rsquo;s interpretation of REST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In terms of the transport, we currently have implementations for local mode and HTTP mode. If you
look at the
&lt;a href=&#34;https://github.com/clearcare/servant/blob/master/examples/calculator_service/README.md&#34; target=&#34;_blank&#34;&gt;README&lt;/a&gt;
you&amp;rsquo;ll see example of how to run the demo via &lt;code&gt;uwsgi&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;trade-offs&#34;&gt;Trade offs&lt;/h2&gt;

&lt;p&gt;As with any technology there are trade-offs. Here are a few issues with servant today:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Currently Python only. Other languages would need a Servant library implemented.&lt;/li&gt;
&lt;li&gt;No mechanism for exploration&amp;hellip;need knowledge of service before hitting it&lt;/li&gt;
&lt;li&gt;Can&amp;rsquo;t simply use curl to hit an endpoint&lt;/li&gt;
&lt;li&gt;Need another layer to expose a service publicly (i.e., hitting from JavaScript)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;closing-thoughts&#34;&gt;Closing thoughts&lt;/h2&gt;

&lt;p&gt;Servant has served us quite well at work and I really would like to keep iterating on it. It&amp;rsquo;s open
source, so if you&amp;rsquo;re interested clone the repo and give it a try. I haven&amp;rsquo;t looked at the current
landscape for service libraries in Python in a while but know that others are popping up here and
there. Still, I do know that there aren&amp;rsquo;t any really big libraries that the community if flocking
to when starting their journey into a microservice architecture. From what I can tell people mostly
reach for a REST or REST-like design when building services.&lt;/p&gt;

&lt;p&gt;In a future post I&amp;rsquo;ll go into some more detail about servant and some ideas that I&amp;rsquo;ve had but
haven&amp;rsquo;t been implemented yet.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>