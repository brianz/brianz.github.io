<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on Brian Z</title>
    <link>http://blog.brianz.bz/tags/architecture/index.xml</link>
    <description>Recent content in Architecture on Brian Z</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016-2017. All rights reserved.</copyright>
    <atom:link href="http://blog.brianz.bz/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to setup a free SSL certificate for use with Serverless APIs</title>
      <link>http://blog.brianz.bz/post/custom-https-domains-with-serverless/</link>
      <pubDate>Thu, 16 Feb 2017 21:21:10 -0700</pubDate>
      
      <guid>http://blog.brianz.bz/post/custom-https-domains-with-serverless/</guid>
      <description>

&lt;p&gt;If you&amp;rsquo;re reading this blog it will become very obvious I&amp;rsquo;m a big fan of the &lt;a href=&#34;https://serverless.com&#34; target=&#34;_blank&#34;&gt;Serverless
framework&lt;/a&gt; to power AWS Lambda and API Gateway integration.&lt;/p&gt;

&lt;p&gt;When building &lt;em&gt;real&lt;/em&gt; APIs that you&amp;rsquo;d like to deploy publicly one thing you&amp;rsquo;ll run into eventually
is that of setting up a custom domain name. API Gateway is fantastic and you can get up and running
in a hurry, exposing a publicly facing API running over SSL. However, the chances of you actually
wanting to use the AWS-provided URL is slim to nil. Do you really want to publish a public API with
the format of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://abcxszhmwi.execute-api.us-west-2.amazonaws.com/dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No. You don&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;In this post I&amp;rsquo;ll use my &lt;a href=&#34;http://blog.brianz.bz/post/serverless-1.0/&#34; target=&#34;_blank&#34;&gt;Dilbert Slack plugin&lt;/a&gt; which I built
in a prior post (and which I&amp;rsquo;m still running on a few different Slack channels). What we&amp;rsquo;ll do is
set up a custom domain with SSL so that &lt;code&gt;https://dilbert.brianz.bz&lt;/code&gt; works just the same as the
default API Gateway URL.&lt;/p&gt;

&lt;p&gt;What is even better&amp;hellip;we&amp;rsquo;ll do this for &lt;strong&gt;FREE&lt;/strong&gt; using a completely legitimate certificate
authority so that our certs don&amp;rsquo;t raise any warnings for users.
Because we&amp;rsquo;re going to be doing this with open source
software there are a few hoops to jump through&amp;hellip;but not that many.  If you feel like shelling out a few
hundred dollars to buy a domain from a certificate authority the process would be super
simple&amp;hellip;but that&amp;rsquo;s no fun.  This process is simple enough that I don&amp;rsquo;t know why anyone shells out
the money for an SSL cert these days (unless you need a wildcard domain&amp;hellip;more about that in
&lt;a href=&#34;#summary&#34; target=&#34;_blank&#34;&gt;at the end of this post&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Here is the overall process we&amp;rsquo;ll use.  First, the tools which I use to accomplish this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker (not required, but handy)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://certbot.eff.org&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;certbot&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DNS zone file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The secret sauce in getting a free SSL certificate is &lt;code&gt;certbot&lt;/code&gt; from the Electric Frontier
Foundation.&lt;/p&gt;

&lt;p&gt;And the steps which I&amp;rsquo;ll cover in detail:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Spin up Docker container using &lt;code&gt;python:2&lt;/code&gt; image&lt;/li&gt;
&lt;li&gt;Install &lt;code&gt;certbot&lt;/code&gt; in container&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;certbot&lt;/code&gt; in container&lt;/li&gt;
&lt;li&gt;Change DNS records as instructed by &lt;code&gt;certbot&lt;/code&gt; to verify domain&lt;/li&gt;
&lt;li&gt;Create a &amp;ldquo;Custom Domain&amp;rdquo; in API Gateway and Install certificate files&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To be clear, there are definitely other ways to accomplish this. This is actually my second
iteration of this process which is easier than my first implementation.
For my purposes I&amp;rsquo;ve found this process to be quite easy and painless. One caveat with &lt;code&gt;certbot&lt;/code&gt;
certificates is that they expire after only three months. This process is so simple I don&amp;rsquo;t think
it&amp;rsquo;s a big deal to do it four times a year.  Sure&amp;hellip;if you&amp;rsquo;re managing dozens of domains it could
get cumbersome, but for a handful of domains it&amp;rsquo;s not a huge deal.&lt;/p&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting started&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;certbot&lt;/code&gt; has many different options and methods for validating that you own the domain for which you&amp;rsquo;re
requesting a domain. I have found that the easiest validation method is via DNS. Other challenge
methods require running an HTTP server on some publicly accessible host. This &lt;em&gt;used&lt;/em&gt; to be the
method I used where I&amp;rsquo;d spin up a nano EC2 instance, run a simple &lt;code&gt;HTTPServer&lt;/code&gt; via Python and have
it serve a some file in response to the HTTP request from &lt;code&gt;certbot&lt;/code&gt;. The DNS challenge is much
simpler&amp;hellip;all it requires is adding an &lt;code&gt;TXT&lt;/code&gt; record without the need to run any additional systems
or software.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m using Docker for all this since it&amp;rsquo;s so easy. &lt;code&gt;certbot&lt;/code&gt; is installable via &lt;code&gt;pip&lt;/code&gt;, however
there are several system dependencies you&amp;rsquo;ll need. Because it&amp;rsquo;s so easy with Docker it&amp;rsquo;s my
suggested method for using &lt;code&gt;certbot&lt;/code&gt;. Here&amp;rsquo;s a two line &lt;code&gt;Dockerfile&lt;/code&gt; which will work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM python:2
RUN pip install certbot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s really that easy.&lt;/p&gt;

&lt;p&gt;My accompanying &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;NAME=&amp;quot;bz/certbot&amp;quot;

.PHONY: all shell

all :
	docker build -t $(NAME) .

shell :
	docker run --rm -it \
		-v `pwd`/letsencrypt:/etc/letsencrypt \
		$(NAME) bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now I&amp;rsquo;ll just:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make
$ # lots of output
Removing intermediate container 71cb0a9bbfb9
Successfully built f93119d079ac
$ mkdir letsencrypt
$ make shell
docker run --rm -it \
                -v `pwd`/letsencrypt:/etc/letsencrypt \
                &amp;quot;bz/certbot&amp;quot; bash
root@ff55a6336d39:/#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Here I&amp;rsquo;m creating a &lt;em&gt;local&lt;/em&gt; directory names &lt;code&gt;letsencrypt&lt;/code&gt; and mounting in into the
container as &lt;code&gt;/etc/letsencrypt&lt;/code&gt;. The reason for that is because &lt;code&gt;certbot&lt;/code&gt; will place all of the
created certificates into &lt;code&gt;/etc/letsencrypt&lt;/code&gt;. We want any created files to persist on our local
system after the container has been removed.&lt;/p&gt;

&lt;h2 id=&#34;creating-the-certificate&#34;&gt;Creating the certificate&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;certbot&lt;/code&gt; has tight integration with Nginx, Apache and other webservers.  However, I have found these to be more
trouble than they are worth since they will actually attempt to write over your config files or
expect your webserver to be able to serve static content from a path which looks like
&lt;code&gt;/.well-known/acme-challenge/fhKqLc6FuM97zg3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What I have found to be super easy is the &lt;code&gt;--manual&lt;/code&gt; method which we&amp;rsquo;ll use here.&lt;/p&gt;

&lt;p&gt;In the docker container:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# certbot certonly --manual -d dilbert.brianz.bz --preferred-challenge dns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What this is saying is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;certonly&lt;/code&gt; &amp;rarr; Only get a certificate&amp;hellip;don&amp;rsquo;t try to install it for me&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--manual&lt;/code&gt; &amp;rarr; Use the interactive mode with prompts&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; &amp;rarr; Request a cert for the domain &lt;code&gt;dilbert.brianz.bz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--preferred-challenges&lt;/code&gt; &amp;rarr; Use DNS for validation rather than a web server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is the full output from my run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@271530c5cbad:/certs# certbot certonly --manual -d dilbert.brianz.bz --preferred-challenges dns
Saving debug log to /var/log/letsencrypt/letsencrypt.log
Obtaining a new certificate
Performing the following challenges:
dns-01 challenge for dilbert.brianz.bz

-------------------------------------------------------------------------------
NOTE: The IP of this machine will be publicly logged as having requested this
certificate. If you&#39;re running certbot in manual mode on a machine that is not
your server, please ensure you&#39;re okay with that.

Are you OK with your IP being logged?
-------------------------------------------------------------------------------
(Y)es/(N)o: Y

-------------------------------------------------------------------------------
Please deploy a DNS TXT record under the name
_acme-challenge.dilbert.brianz.bz with the following value:

tBkgiRMxuIGSKH-WzJiJMTCi5uuEsZUUJJmg8FIBZ40

Once this is deployed,
-------------------------------------------------------------------------------
Press Enter to Continue
Waiting for verification...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-txt-record&#34;&gt;Create TXT record&lt;/h2&gt;

&lt;p&gt;This part is easy enough. Simply add a &lt;code&gt;TXT&lt;/code&gt; record in your DNS zone file as instructed. I&amp;rsquo;m using
Route53 and this is what it looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.brianz.bz/images/api-gateway-ssl/route53-txt-record.png&#34; alt=&#34;Add TXT record&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It may take a bit for this record to propagate.  You can check that it&amp;rsquo;s returning the correct value
using &lt;code&gt;dig&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dig -t TXT _acme-challenge.dilbert.brianz.bz
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;finishing-off-challenge&#34;&gt;Finishing off challenge&lt;/h2&gt;

&lt;p&gt;Once your &lt;code&gt;TXT&lt;/code&gt; record is working, simply hit enter back in the &lt;code&gt;certbot&lt;/code&gt; prompt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Cleaning up challenges
Generating key (2048 bits): /etc/letsencrypt/keys/0000_key-certbot.pem
Creating CSR: /etc/letsencrypt/csr/0000_csr-certbot.pem

IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at
   /etc/letsencrypt/live/dilbert.brianz.bz/fullchain.pem. Your cert will
   expire on 2017-05-18. To obtain a new or tweaked version of this
   certificate in the future, simply run certbot again. To
   non-interactively renew *all* of your certificates, run &amp;quot;certbot
   renew&amp;quot;
 - If you like Certbot, please consider supporting our work by:

   Donating to ISRG / Let&#39;s Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice! Again, you&amp;rsquo;ll notice that &lt;code&gt;certbot&lt;/code&gt; put the keys in &lt;code&gt;/etc/letsencrypt&lt;/code&gt;. If you&amp;rsquo;re using
Docker like I am these will now be sitting on your host system. It&amp;rsquo;s now safe to kill the
container.&lt;/p&gt;

&lt;p&gt;There are four certificate files created:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pwd
/Users/brianz/dev/certbot/letsencrypt/live/dilbert.brianz.bz
$ ls -l
-rw-r--r--  1 brianz  staff  543 Feb 16 16:56 README
lrwxr-xr-x  1 brianz  staff   38 Feb 16 16:56 cert.pem -&amp;gt; ../../archive/dilbert.brianz.bz/cert1.pem
lrwxr-xr-x  1 brianz  staff   39 Feb 16 16:56 chain.pem -&amp;gt; ../../archive/dilbert.brianz.bz/chain1.pem
lrwxr-xr-x  1 brianz  staff   43 Feb 16 16:56 fullchain.pem -&amp;gt; ../../archive/dilbert.brianz.bz/fullchain1.pem
lrwxr-xr-x  1 brianz  staff   41 Feb 16 16:56 privkey.pem -&amp;gt; ../../archive/dilbert.brianz.bz/privkey1.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;setting-up-custom-domain-with-api-gateway&#34;&gt;Setting up custom domain with API Gateway&lt;/h2&gt;

&lt;p&gt;Now that we have our certificate files, it&amp;rsquo;s time to set up a custom domain in API Gateway. How
this will work is the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a custom domain in API Gateway and upload certificate files&lt;/li&gt;
&lt;li&gt;Point the new custom domain at the desired API&lt;/li&gt;
&lt;li&gt;Wait for Cloudfront distribution to complete&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First up, navigate to the API Gateway console and click on &amp;ldquo;Custom Domain Names&amp;rdquo; followed by the
&amp;ldquo;Create&amp;rdquo; button.&lt;/p&gt;

&lt;p&gt;Now, you&amp;rsquo;ll need to copy and paste the correct files into the correct locations. The mapping
between &lt;code&gt;certbot&lt;/code&gt; certificate files and API Gateway Custom Domain form fields is the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cert.pem&lt;/code&gt; &amp;rarr; Certificate body&lt;/li&gt;
&lt;li&gt;&lt;code&gt;privkey.pem&lt;/code&gt; &amp;rarr; Certificate private key&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chain.pem&lt;/code&gt; &amp;rarr; Certificate chain&lt;/li&gt;
&lt;/ul&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.brianz.bz/images/api-gateway-ssl/create-custom-domain-name.png&#34; alt=&#34;Creating custom domain&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Note, this screen-shot is from when I set up a different Custom Domain Name mapping
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Once you&amp;rsquo;ve clicked the Save button it&amp;rsquo;s time to point this domain at a particular API and stage.&lt;/p&gt;

&lt;p&gt;For this example it&amp;rsquo;s going to be easy&amp;hellip;I&amp;rsquo;ll point the root domain (i.e., &lt;code&gt;dilbert.brianz.bz&lt;/code&gt;) at
my single &lt;code&gt;dev&lt;/code&gt; stage for my API.  Click &amp;ldquo;Create API mapping&amp;rdquo; an put in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Base path &amp;rarr; Leave blank&lt;/li&gt;
&lt;li&gt;API &amp;rarr; Select your desired API distribution&lt;/li&gt;
&lt;li&gt;State &amp;rarr; Select your desired stage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.brianz.bz/images/api-gateway-ssl/custom-domain-mapping.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you have a more complicated setup, you could do something like the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;point &lt;code&gt;dilbert.brianz.bz/api/dev&lt;/code&gt; to the &lt;code&gt;dev&lt;/code&gt; stage or &lt;code&gt;dilbert-dev&lt;/code&gt; Serverless service.&lt;/li&gt;
&lt;li&gt;point &lt;code&gt;dilbert.brianz.bz/api/qa&lt;/code&gt; to the &lt;code&gt;qa&lt;/code&gt; stage or &lt;code&gt;dilbert-qa&lt;/code&gt; Serverless service.&lt;/li&gt;
&lt;li&gt;point &lt;code&gt;dilbert.brianz.bz/api/&lt;/code&gt; to the &lt;code&gt;production&lt;/code&gt; stage or &lt;code&gt;dilbert-production&lt;/code&gt; service.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You get the idea&amp;hellip;this is a way to create different environments by pointing URLs at completely
different systems.&lt;/p&gt;

&lt;p&gt;Once that is done, you&amp;rsquo;ll be greeted with the following:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.brianz.bz/images/api-gateway-ssl/cloudfront-distribution-creating.png&#34; alt=&#34;Cloudfront creat&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Again, note this screen-shot is from when I set up a different Custom Domain Name mapping
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;This process really can take a long time.  While the message states &amp;ldquo;Up to 40 minutes&amp;rdquo; I&amp;rsquo;ve
experienced wait times of several hours.&lt;/p&gt;

&lt;p&gt;However, after the wait is over and the Cloudfront distribution is created, we now have a perfectly
valid SSL certificate which I can use for my API.  Hitting &lt;a href=&#34;https://dilbert.brianz.bz&#34; target=&#34;_blank&#34;&gt;https://dilbert.brianz.bz&lt;/a&gt; from Slack
works as expected.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;certbot&lt;/code&gt; is a great tool to create perfectly valid and completely free ssl certificates. Creating
these certs with the &lt;code&gt;--manual&lt;/code&gt; method and the &lt;code&gt;dns&lt;/code&gt; validation method is a simple way to get certs
for use with API Gateway&amp;rsquo;s Custom Domain Name feature. Since these certs expire every three months
you&amp;rsquo;ll need to renew a bit more often than with a paid SSL certificate, however the process isn&amp;rsquo;t
that complicated and in my book the extra work is worth the price savings.&lt;/p&gt;

&lt;p&gt;Finally, I should note that &lt;code&gt;certbot&lt;/code&gt; does not work with wildcard domains. If you have several
subdomains you need certs for your only choice is to shell out the money for a wildcard domain from
one of the commercial CAs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serverless 1.x</title>
      <link>http://blog.brianz.bz/post/serverless-1.0/</link>
      <pubDate>Wed, 21 Dec 2016 12:04:30 -0700</pubDate>
      
      <guid>http://blog.brianz.bz/post/serverless-1.0/</guid>
      <description>

&lt;p&gt;Since my last posts on &lt;a href=&#34;https://serverless.com&#34; target=&#34;_blank&#34;&gt;Serverless&lt;/a&gt;, Serverless has gone 1.0. In fact, as
of this writing Serverless is at version 1.3.  I&amp;rsquo;ve had the luck of taking 1.3 for a spin with my
new job by implementing an application for the Amazon Alexa platform. Alexa has a really nice
integration with Lambda and we&amp;rsquo;ve been using Serverless to do our Lambda development. Our
development pace has been insanely high and much of that can be attributed to Serverless.&lt;/p&gt;

&lt;p&gt;The 1.x versions of Serverless is drastically different than the 0.x versions I previously wrote
about. In fact, I believe it was a total or near-total rewrite of the library itself. With such a
drastic change I&amp;rsquo;d like to do another walk-through starting from scratch and ending up with a
working application. In addition to changes in the Serverless library comes with changes and &lt;em&gt;huge&lt;/em&gt;
improvements in API Gateway and Lambda themselves. The great news is that authoring a service with
these tools is getting even easier.&lt;/p&gt;

&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;

&lt;p&gt;To get started, I like to run Serverless inside of a Docker container  Why? Because I &amp;hearts;
Docker and it makes switching versions &lt;em&gt;trivial&lt;/em&gt; without mucking with your local system. Since I
use Python I usually install a few base Python packages while I&amp;rsquo;m at it:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/e08a480d772051b1b64e99cfeee6315e.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Of course, before you get started you&amp;rsquo;ll need to have AWS credentials available which allow you to
create resources. If you do any amount of AWS work changes are you&amp;rsquo;ll have &lt;code&gt;AWS_ACCESS_KEY_ID&lt;/code&gt; and
&lt;code&gt;AWS_ACCESS_SECRET_KEY&lt;/code&gt; on your local system. What I do is simply copy these into a file called
&lt;code&gt;.env&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ env | grep AWS &amp;gt;&amp;gt; .env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, I can easily inject these into my Docker container using &lt;code&gt;--env-file .env&lt;/code&gt;. If you are
running on your local system you&amp;rsquo;ll need to have these two &lt;code&gt;AWS&lt;/code&gt; variables set. See the &lt;a href=&#34;https://serverless.com/framework/docs/providers/aws/guide/credentials/&#34; target=&#34;_blank&#34;&gt;Serverless
docs on credentials&lt;/a&gt; for
more details on AWS credentials if you need it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Code snippets will be running inside my Docker container&lt;/p&gt;

&lt;h1 id=&#34;create-a-serverless-project&#34;&gt;Create a Serverless project&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s create a really simple Slack plugin. What we&amp;rsquo;ll do is create an HTTP API which will reply
with a URL to a Dilbert comic.  For example: &lt;a href=&#34;http://dilbert.com/strip/2016-11-28&#34; target=&#34;_blank&#34;&gt;http://dilbert.com/strip/2016-11-28&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can see that the date is embedded directly into the URL so it should be pretty easy to generate
a URL for &amp;ldquo;today&amp;rdquo; or on a specific date.  Let&amp;rsquo;s define our Slack Slash Command language as the
following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/dilbert&lt;/code&gt; &amp;rarr; Reply with today&amp;rsquo;s comic&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dilbert random&lt;/code&gt; &amp;rarr; Reply with a random comic from the past year&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dilbert yesterday&lt;/code&gt; &amp;rarr; Reply with yesterday&amp;rsquo;s comic&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dilbert $N days ago&lt;/code&gt; &amp;rarr; Reply with a comic from &lt;code&gt;$N&lt;/code&gt; days ago where &lt;code&gt;$N&lt;/code&gt; can be numeric or
                            plain English&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dilbert $DATE&lt;/code&gt; &amp;rarr; Reply with a comic from a specific date with multiple formats&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ll leave the Slack setup to you&amp;hellip;but the long and short of it is that you&amp;rsquo;ll need to add a new
&amp;ldquo;Slash Command&amp;rdquo; and plug in the API Gateway URL once we have it.&lt;/p&gt;

&lt;p&gt;Now, on to the Serverless!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new project. As usual, we&amp;rsquo;ll be using Python to implement our application code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ serverless create --template aws-python --path dilbert --name dilbert
Serverless: Generating boilerplate...
Serverless: Generating boilerplate in &amp;quot;/code/dilbert&amp;quot;
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v1.2.0
 -------&#39;

Serverless: Successfully generated boilerplate for template: &amp;quot;aws-python&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s &lt;code&gt;cd dilbert&lt;/code&gt; and take a look at the files which were generated:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tree dilbert/
dilbert/
├── event.json
├── handler.py
└── serverless.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very similar to previous versions of Serverless and much different at the same time.
Previously we would have received a higher level &lt;code&gt;s-project.json&lt;/code&gt; and &lt;code&gt;s-resources-cf.json&lt;/code&gt; files.&lt;/p&gt;

&lt;h1 id=&#34;setup-api-gateway&#34;&gt;Setup API Gateway&lt;/h1&gt;

&lt;p&gt;Crack open &lt;code&gt;serverless.yml&lt;/code&gt; and you&amp;rsquo;ll see the details on how your function and endpoint(s) are
configured.  First, let&amp;rsquo;s tune back the memory and timeout&amp;hellip;we&amp;rsquo;re running a very small Lambda
function so we can tune these both back to some pretty small values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;service: dilbert

provider:
  name: aws 
  runtime: python2.7
  stage: dev 
  region: us-west-2
  memorySize: 256 
  timeout: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to wire something up to our Lambda functions we use the &lt;code&gt;functions&lt;/code&gt; block. What is nice
here is that we can now define multiple functions inside of a given &amp;ldquo;service&amp;rdquo;.
In prior Serverless versions a single function was a bit more self-contained and it was
hard or unclear how to define a &amp;ldquo;service&amp;rdquo; vs a &amp;ldquo;function&amp;rdquo;.  Now, it&amp;rsquo;s much more clear&amp;hellip;we have
created a Serverless &amp;ldquo;service&amp;rdquo; which can be made up of one or more &amp;ldquo;functions&amp;rdquo;, all sharing the
same resources (which we&amp;rsquo;ll get to later).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;functions:
  hello:
    handler: handler.hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important to note here the &lt;code&gt;handler&lt;/code&gt; is really just pointing to &lt;code&gt;handler.py&lt;/code&gt;.
&lt;code&gt;handler.hello&lt;/code&gt; then is just telling Serverless to setup a Lambda function which invokes the
&lt;code&gt;hello&lt;/code&gt; function in your &lt;code&gt;handler.py&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;For a Slash commands we want to setup an API endpoint which response to &lt;code&gt;GET&lt;/code&gt; requests. Under the
same &lt;code&gt;function&lt;/code&gt; block let&amp;rsquo;s add an HTTP &lt;code&gt;GET&lt;/code&gt; event as a trigger to our Lambda function. Serverless
will pick this up and setup our API Gateway entry-point and wire it together with our Lambda
function/handler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;functions:
  hello:
    handler: handler.hello
    events:
     - http:
         path: /
         method: get 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, quite simple. Serverless is going to take this and create an API Gateway endpoint which
responds to &lt;code&gt;GET&lt;/code&gt; requests at the root.&lt;/p&gt;

&lt;h1 id=&#34;deployment&#34;&gt;Deployment&lt;/h1&gt;

&lt;p&gt;Now, let&amp;rsquo;s deploy this and watch Serverless work its magic:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@ae95b29ae049:/code/dilbert$ sls deploy 
Serverless: Packaging service...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading service .zip file to S3 (2.19 KB)...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
........................
Serverless: Stack update finished...

Service Information
service: dilbert
stage: dev
region: us-west-2
api keys:
  None
endpoints:
  GET - https://cjkxszhmwi.execute-api.us-west-2.amazonaws.com/dev/
functions:
  dilbert-dev-hello: arn:aws:lambda:us-west-2:420819310858:function:dilbert-dev-hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great&amp;hellip;let&amp;rsquo;s hit our endpoint:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s ps://cjkxszhmwi.execute-api.us-west-2.amazonaws.com/dev/ | python -mjson.tool 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;input&amp;quot;: {
        &amp;quot;body&amp;quot;: null,
        &amp;quot;headers&amp;quot;: {
            &amp;quot;Accept&amp;quot;: &amp;quot;*/*&amp;quot;,
            &amp;quot;CloudFront-Forwarded-Proto&amp;quot;: &amp;quot;https&amp;quot;,
            &amp;quot;CloudFront-Is-Desktop-Viewer&amp;quot;: &amp;quot;true&amp;quot;,
            &amp;quot;CloudFront-Is-Mobile-Viewer&amp;quot;: &amp;quot;false&amp;quot;,
            &amp;quot;CloudFront-Is-SmartTV-Viewer&amp;quot;: &amp;quot;false&amp;quot;,
            &amp;quot;CloudFront-Is-Tablet-Viewer&amp;quot;: &amp;quot;false&amp;quot;,
            &amp;quot;CloudFront-Viewer-Country&amp;quot;: &amp;quot;US&amp;quot;,
            &amp;quot;Host&amp;quot;: &amp;quot;cjkxszhmwi.execute-api.us-west-2.amazonaws.com&amp;quot;,
            &amp;quot;User-Agent&amp;quot;: &amp;quot;curl/7.43.0&amp;quot;,
            &amp;quot;Via&amp;quot;: &amp;quot;1.1 d3faf01897d35b8f07de2d81452478f1.cloudfront.net (CloudFront)&amp;quot;,
            &amp;quot;X-Amz-Cf-Id&amp;quot;: &amp;quot;yXNYMvCXFNa7Wc5DYIo5mBSd_DrzDFEll-2-b8dZN8qneqf4rnxX2A==&amp;quot;,
            &amp;quot;X-Forwarded-For&amp;quot;: &amp;quot;174.29.177.16, 216.137.38.83&amp;quot;,
            &amp;quot;X-Forwarded-Port&amp;quot;: &amp;quot;443&amp;quot;,
            &amp;quot;X-Forwarded-Proto&amp;quot;: &amp;quot;https&amp;quot;
        },
        &amp;quot;httpMethod&amp;quot;: &amp;quot;GET&amp;quot;,
        &amp;quot;isBase64Encoded&amp;quot;: false,
        &amp;quot;path&amp;quot;: &amp;quot;/&amp;quot;,
        &amp;quot;pathParameters&amp;quot;: null,
        &amp;quot;queryStringParameters&amp;quot;: null,
        &amp;quot;requestContext&amp;quot;: {
            &amp;quot;accountId&amp;quot;: &amp;quot;444444444444&amp;quot;,
            &amp;quot;apiId&amp;quot;: &amp;quot;cjkxszhmwi&amp;quot;,
            &amp;quot;httpMethod&amp;quot;: &amp;quot;GET&amp;quot;,
            &amp;quot;identity&amp;quot;: {
                &amp;quot;accessKey&amp;quot;: null,
                &amp;quot;accountId&amp;quot;: null,
                &amp;quot;apiKey&amp;quot;: null,
                &amp;quot;caller&amp;quot;: null,
                &amp;quot;cognitoAuthenticationProvider&amp;quot;: null,
                &amp;quot;cognitoAuthenticationType&amp;quot;: null,
                &amp;quot;cognitoIdentityId&amp;quot;: null,
                &amp;quot;cognitoIdentityPoolId&amp;quot;: null,
                &amp;quot;sourceIp&amp;quot;: &amp;quot;174.29.177.16&amp;quot;,
                &amp;quot;user&amp;quot;: null,
                &amp;quot;userAgent&amp;quot;: &amp;quot;curl/7.43.0&amp;quot;,
                &amp;quot;userArn&amp;quot;: null
            },
            &amp;quot;requestId&amp;quot;: &amp;quot;f5096723-b5de-11e6-abfe-bdf276cfb36a&amp;quot;,
            &amp;quot;resourceId&amp;quot;: &amp;quot;96p3xs47w7&amp;quot;,
            &amp;quot;resourcePath&amp;quot;: &amp;quot;/&amp;quot;,
            &amp;quot;stage&amp;quot;: &amp;quot;dev&amp;quot;
        },
        &amp;quot;resource&amp;quot;: &amp;quot;/&amp;quot;,
        &amp;quot;stageVariables&amp;quot;: null
    },
    &amp;quot;message&amp;quot;: &amp;quot;Go Serverless v1.0! Your function executed successfully!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One &lt;em&gt;really&lt;/em&gt; nice thing is a change to the Lambda/API Gateway integration from the AWS team. There
is something now called a &amp;ldquo;Lambda-Proxy&amp;rdquo; integration with Gateway. This makes the integration and
passing of data between Lambda and Gateway super simple. You should use it. Notice above there is a
field called &lt;code&gt;queryStringParameters&lt;/code&gt;. Let&amp;rsquo;s make another request and send some &lt;code&gt;GET&lt;/code&gt; arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -s https://cjkxszhmwi.execute-api.us-west-2.amazonaws.com/dev/ -G --data-urlencode &amp;quot;date=two days ago&amp;quot; | python -mjson.tool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the response, it should be no surprise that we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;queryStringParameters&amp;quot;: {
    &amp;quot;date&amp;quot;: &amp;quot;two days ago&amp;quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is fantastic. Previously getting query parameters from Gateway into Lambda was quite tedious
and much more complicated than it should have been. Now, we get this out of the box which is really
what we should all expect.&lt;/p&gt;

&lt;h1 id=&#34;building-our-application&#34;&gt;Building our application&lt;/h1&gt;

&lt;p&gt;Now that we have the boilerplate (mostly) out of the way we can focus on our actual Dilbert
application. I won&amp;rsquo;t cover the details of it, but instead show the finished product based on our
little spec above for the Slash commands.&lt;/p&gt;

&lt;p&gt;You can see the final results here: &lt;a href=&#34;https://github.com/brianz/dilbert-slack-bot&#34; target=&#34;_blank&#34;&gt;https://github.com/brianz/dilbert-slack-bot&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are some highlights of how this is implemented.&lt;/p&gt;

&lt;p&gt;For this project, let&amp;rsquo;s rename the function from &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;dilbert&lt;/code&gt; in &lt;code&gt;serverless.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;functions:
  dilbert:
    handler: handler.dilbert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our &lt;code&gt;handler.py&lt;/code&gt; file we&amp;rsquo;ll now implement a function called &lt;code&gt;dilbert&lt;/code&gt; which will accept the same
two parameters as the &lt;code&gt;hello&lt;/code&gt; function, the http event/request and the request context. This
function will contain all of the logic to parse the request text from Slack and figure out what to
respond with.  The details on how to do this are really details around Slack, not details about
Serverless. If you&amp;rsquo;re curious about the details you can simply &lt;a href=&#34;https://github.com/brianz/dilbert-slack-bot/blob/master/dilbert/handler.py&#34; target=&#34;_blank&#34;&gt;read the handler.py
source&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In order to reply with a nice Slack message we&amp;rsquo;d like to embed the comic&amp;rsquo;s image in the Slack
response. This requires parsing the dilbert.com page for a given day and extracting the image&amp;rsquo;s
URL. For performance reason&amp;rsquo;s, it&amp;rsquo;d be nice to cache this value&amp;hellip;so let&amp;rsquo;s put the image&amp;rsquo;s URL in
DynamoDB!&lt;/p&gt;

&lt;h2 id=&#34;building-arbitrary-resources&#34;&gt;Building arbitrary resources&lt;/h2&gt;

&lt;p&gt;Because Serverless uses CloudFormation to create your service it&amp;rsquo;s possible to create and manage
arbitrary AWS resources such as DynamoDB. For our purposes, we&amp;rsquo;d like to create a DynamoDB table to
cache image urls when we create our stack.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;resources:
  Resources:
    dynamoUsersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: devDilbert
        AttributeDefinitions:
          - AttributeName: postDay
            AttributeType: S
        KeySchema:
          - AttributeName: postDay
            KeyType: HASH
        ProvisionedThroughput:
          ReadCapacityUnits: 1
          WriteCapacityUnits: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very cool. During any &lt;code&gt;sls deploy&lt;/code&gt; command Serverless will manage this DynamoDB table for
us, whether that be creating it on the initial &lt;code&gt;sls deploy&lt;/code&gt; or updating it if we change any of its
attributes.&lt;/p&gt;

&lt;p&gt;One &amp;ldquo;gotcha&amp;rdquo; with this is that we need an IAM policy so that our Lambda function (ie, our
application code in &lt;code&gt;handler.py&lt;/code&gt;) has access.  To add the IAM policy we put this block under our
&lt;code&gt;provider&lt;/code&gt; block in &lt;code&gt;serverless.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;provider:
  ...
  iamRoleStatements:
    - Effect: &amp;quot;Allow&amp;quot;
      Action:
        - &amp;quot;dynamodb:*&amp;quot;
      Resource: &amp;quot;arn:aws:dynamodb:${self:provider.region}:*:table/devDilbert&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;deploying-and-iterations&#34;&gt;Deploying and iterations&lt;/h2&gt;

&lt;p&gt;Once this is all setup we can now do another &lt;code&gt;sls deploy&lt;/code&gt;. Serverless will set up our DynamoDB
table and update our Lambda function appropriately.&lt;/p&gt;

&lt;p&gt;During development it&amp;rsquo;s very common to deploy your code, test it, find a bug and then redeploy.
For me this cycle consists of the following (after the initial deployment):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;test&lt;/li&gt;
&lt;li&gt;look in AWS Cloudwatch for any errors or debugging output&lt;/li&gt;
&lt;li&gt;fix bugs&lt;/li&gt;
&lt;li&gt;redeploy &lt;em&gt;just the function&lt;/em&gt; with &lt;code&gt;sls deploy function -f function-name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The redeployment goes much quicker if you only deploy the actual function/application code to
Lambda.  A full &lt;code&gt;sls deploy&lt;/code&gt; will manage the entire stack/service through Cloudformation which can
take a few seconds. On the other hand, &lt;code&gt;sls deploy function -f dilbert&lt;/code&gt; will simply upload the
current version of &lt;code&gt;handler.py&lt;/code&gt; and supporting files to Lambda. This takes just a few seconds at
most.&lt;/p&gt;

&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;

&lt;p&gt;After deployment and getting Slack configured here&amp;rsquo;s the end result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.brianz.bz/images/dilbert/dilbert.png&#34; alt=&#34;Dilbert in Slack&#34; style=&#34;width: 680px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.brianz.bz/images/dilbert/dilbert-random.png&#34; alt=&#34;Dilbert random in Slack&#34; style=&#34;width: 680px;&#34;/&gt;&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;Serverless 1.X is much improved over the 0.X versions. I have found it to be much easier to use
especially when collaborating with other developers. The notion of a &amp;ldquo;service&amp;rdquo; makes a lot of
sense and allows for better organization and sharing of resources. Finally, the ability to create
and manage arbitrary AWS resources allows us to quickly and easily deploy a real stand-alone
microservice.&lt;/p&gt;

&lt;p&gt;This post didn&amp;rsquo;t talk at all about Serverless &amp;ldquo;stages&amp;rdquo;, but using &amp;ldquo;stages&amp;rdquo; in effect let&amp;rsquo;s us
manage different stacks for &amp;ldquo;production&amp;rdquo;, &amp;ldquo;dev&amp;rdquo;, &amp;ldquo;staging&amp;rdquo;, etc. This is the equivalent of having a
staging server vs production server in a typical web application deployment.&lt;/p&gt;

&lt;p&gt;Serverless continues to make huge strides forward and I&amp;rsquo;ve already been able to move quickly on a
few different projects.  I&amp;rsquo;m excited to see what&amp;rsquo;s coming next in Serverless to make application
and microservice development even easier.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Demo service with Servant</title>
      <link>http://blog.brianz.bz/post/demo-service-with-servant/</link>
      <pubDate>Thu, 15 Sep 2016 17:41:39 -0400</pubDate>
      
      <guid>http://blog.brianz.bz/post/demo-service-with-servant/</guid>
      <description>

&lt;p&gt;In a &lt;a href=&#34;http://blog.brianz.bz/post/introducing-servant/&#34;&gt;previous post&lt;/a&gt; I introduced and discussed
about an open source library I authored called Servant. Servant is a framework for building
RPC-style services with Python. Servant is to services as Django or Rails is to web
applications&amp;hellip;it&amp;rsquo;s framework you&amp;rsquo;d use when you need to build a service in Python.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll go a bit deeper in this post and show what it&amp;rsquo;s like to actually author and use a service.
Let&amp;rsquo;s first start by writing the service.  To save some time we&amp;rsquo;ll take a look at the &lt;a
href=&#34;https://github.com/brianz/servant/tree/master/examples/calculator_service&#34;&gt;&lt;code&gt;calculator_service&lt;/code&gt;&lt;/a&gt;
which is in the &lt;code&gt;examples&lt;/code&gt; directory in the Servant repository.&lt;/p&gt;

&lt;h2 id=&#34;writing-the-service&#34;&gt;Writing the service&lt;/h2&gt;

&lt;h3 id=&#34;boilerplate&#34;&gt;Boilerplate&lt;/h3&gt;

&lt;p&gt;There are a few requirements to write a service.  I&amp;rsquo;ll start with the boring parts which is mostly
boilerplate to get your service setup as an install-able Python package. I also suggest looking at
the directory structure for the demo &lt;code&gt;calculator_service&lt;/code&gt; on Github:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/brianz/servant/tree/master/examples/calculator_service&#34; target=&#34;_blank&#34;&gt;https://github.com/brianz/servant/tree/master/examples/calculator_service&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;At a bare minimum you&amp;rsquo;ll need a &lt;code&gt;setup.py&lt;/code&gt; file and a directory with the correct name.  In this
example, the name is &lt;code&gt;calculator_service&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/eab945699d396a5656e355e8f1264562.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;From there you&amp;rsquo;ll also need a directory where your source code will live.&lt;/p&gt;

&lt;h3 id=&#34;service&#34;&gt;Service&lt;/h3&gt;

&lt;p&gt;Every Servant service needs an entry-point to device the endpoints which will be exposed. This is
pretty simple&amp;hellip;create a file names &lt;code&gt;service.py&lt;/code&gt; which contains a class that subclasses
&lt;code&gt;servant.service.base.Service&lt;/code&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/7addb2cf37a6cadda3d15fd6c623bf21.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Your service class will only need a few things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; attribute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;version&lt;/code&gt; attribute (use &lt;code&gt;1&lt;/code&gt; when getting started)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;action_map&lt;/code&gt; which is a dictionary mapping endpoint name to an &lt;code&gt;Action&lt;/code&gt; class&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;rsquo;s really it&amp;hellip;of course there are more things you can do in your service class to handle
configuration, etc. However, this is the minimum amount of work you&amp;rsquo;ll need to do in order to get
started.&lt;/p&gt;

&lt;p&gt;In our example you can see our &lt;code&gt;calculator_service&lt;/code&gt; exposed three calculate endpoints&amp;hellip;&lt;code&gt;add&lt;/code&gt;,
&lt;code&gt;subtract&lt;/code&gt; and &lt;code&gt;divide&lt;/code&gt;.  These will do what you&amp;rsquo;d expect.&lt;/p&gt;

&lt;h3 id=&#34;actions&#34;&gt;Actions&lt;/h3&gt;

&lt;p&gt;An &lt;code&gt;Action&lt;/code&gt; is really the meat and potatoes for a particular endpoint. You can organize your
actions however you like&amp;hellip;one action per file, multiple actions per file, etc.  Since we&amp;rsquo;re
writing a pretty simple service and only have three actions, we&amp;rsquo;ll put them all in &lt;code&gt;actions.py&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/91b2a58709d569443aab5b98aaa38e0b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Let&amp;rsquo;s walk through what it takes to implement a single action (or, an &amp;ldquo;endpoint&amp;rdquo; from the client&amp;rsquo;s
perspective).  Looking at &lt;code&gt;AddAction&lt;/code&gt; we can see that there are two required inputs&amp;hellip;&lt;code&gt;number1&lt;/code&gt; and
&lt;code&gt;number2&lt;/code&gt;. I liken the structure of a servant &lt;code&gt;Action&lt;/code&gt; to a Django, SQLAlchemy or other type of
model.  You&amp;rsquo;ll need to subclass &lt;code&gt;servant.service.actions.Action&lt;/code&gt; and usually define one or more
inputs as class attributes which are servant &lt;code&gt;field&lt;/code&gt; types.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;AddAction&lt;/code&gt; we ensure that the client passes us &lt;code&gt;number1&lt;/code&gt; and &lt;code&gt;number2&lt;/code&gt; by adding
&lt;code&gt;required=True&lt;/code&gt; to the field&amp;rsquo;s kwargs. This instructs servant to return an error in the case that
the client doesn&amp;rsquo;t pass either of these. Out of the box we get some error checking for free which
is quite nice.  From there it&amp;rsquo;s also your responsibility as the developer to device the return type
which the client will get back after a successful call.  Here, we&amp;rsquo;ll return a single integer using
an &lt;code&gt;IntField&lt;/code&gt; field type which is named &lt;code&gt;result&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your entry point into an action is the &lt;code&gt;run&lt;/code&gt; method.  You can see above what it does&amp;hellip;it&amp;rsquo;s simple
one-liner.  By the time your &lt;code&gt;run&lt;/code&gt; method is being executed the basic error checking has completed
and all of the required and optional fields will be available to you as class attributes.  So, our
&lt;code&gt;run&lt;/code&gt; method simple sets the result using the two inputs we received from the client:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def run(self, **kwargs):
    self.result = self.number1 + self.number2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; method doesn&amp;rsquo;t need to return anything&amp;hellip;all return data is handled via the field
attributes.&lt;/p&gt;

&lt;p&gt;If you read the rest of the gist above you can see how the subtract and divide actions are
implemented. Being a calculator, there really isn&amp;rsquo;t much to it.  You&amp;rsquo;ll notice that the subtract
action subclassed the add action and just overrides the &lt;code&gt;run&lt;/code&gt; method.  The &lt;code&gt;divide&lt;/code&gt; action mostly
just changes the names of the inputs and output.&lt;/p&gt;

&lt;h2 id=&#34;using-the-service&#34;&gt;Using the service&lt;/h2&gt;

&lt;p&gt;One neat feature of Servant is the ability to run your service as a locally installed Python
library.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s install both Servant and the calculator service into a new virtualenv:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd path/to/servant
$ mkvirtualenv calculator_service
$ pip install -e .
$ cd examples/calculator_service
$ pip install -e .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have these installed, we can actually test our service!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import servant.client

client = servant.client.Client(&#39;calculator_service&#39;, version=1)

response = client.add(number1=10, number2=15)

if response.is_error():
    print response.errors, response.field_errors
else:
    print response.result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this, we get our expected result of &lt;code&gt;25&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, how do we run this on a separate host so that we&amp;rsquo;re actually a stand-alone service?  Quite
easy&amp;hellip;first we&amp;rsquo;ll setup a &lt;code&gt;wsgi&lt;/code&gt; server using &lt;code&gt;uwsgi&lt;/code&gt;. We need two files&amp;hellip;one is a 3-line python
file which is the entry-point for the service.  The other is a very short &lt;code&gt;uwsgi&lt;/code&gt; config file.
Servant has built-in support for running as a wsgi server so &lt;code&gt;wsgi_handler.py&lt;/code&gt; is quite short:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/brianz/f74825460c85c5b5f59255d644a2576a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Now, fire up uwsgi: &lt;code&gt;uwsgi uwsgi.ini&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;uwsgi is now ready to serve requests on port 8888&amp;hellip;we can run the &lt;em&gt;exact&lt;/em&gt; same client code as
above.  You&amp;rsquo;ll note that the client code above &lt;em&gt;only&lt;/em&gt; depends on the &lt;code&gt;servant&lt;/code&gt; library. Really, the
only reference to the &lt;code&gt;calculator_service&lt;/code&gt; is when we instantiate the &lt;code&gt;Client&lt;/code&gt; class.  There is
only one change we need to make to the client code above to hit a remote system:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;client.configure(&#39;http&#39;, host=&#39;192.168.88.100&#39;, port=8888)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re configuring our client to connect via &lt;code&gt;http&lt;/code&gt; to the given host and port.  Once that single
line is added we can run the client and get the exact same results.&lt;/p&gt;

&lt;p&gt;I believe the power of being able to develop a service and run it locally like this and deploy it
remotely with only a single line changing for the client is immensely powerful. Admittedly, when
using Docker standing up a server is pretty easy, but being able to run service code without
depending on a server is still quite valuable. Another big advantage is that it&amp;rsquo;s possible to
actually pip install your service package with your client application and not depend on a remote
system staying up. The advantage is by pip installing a service is that you&amp;rsquo;re able to deploy a
service much faster and iterate simply by pip installing&amp;hellip;when it&amp;rsquo;s time to migrate it&amp;rsquo;s just a
matter of a minor change to your client code to point to the remote host.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serverless part IV</title>
      <link>http://blog.brianz.bz/post/serverless-part-iv/</link>
      <pubDate>Fri, 01 Jul 2016 11:55:51 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/serverless-part-iv/</guid>
      <description>

&lt;p&gt;Welcome to part four in my series about &lt;a href=&#34;http://serverless.com&#34; target=&#34;_blank&#34;&gt;Serverless&lt;/a&gt;. As a reminder, there
are now three other parts you can read if you aren&amp;rsquo;t coming here from those posts already:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.brianz.bz/post/serverless-part-i/&#34; target=&#34;_blank&#34;&gt;Serverless Part I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.brianz.bz/post/serverless-part-ii/&#34; target=&#34;_blank&#34;&gt;Serverless Part II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.brianz.bz/post/serverless-part-iii/&#34; target=&#34;_blank&#34;&gt;Serverless Part III&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the previous posts I worked through some of the basics of Serverless and stood up an API
endpoint which returned HTML.  Now I&amp;rsquo;d like to start working through some more real-world examples
and talk through some warts I&amp;rsquo;ve found with Serverless.  Of course, no project is
perfect&amp;hellip;Serverless is still quite new and the team behind it is making great progress.  As of
this writing there are a few stumbling blocks which can be solved but are not quite as easy as they
could be. I think the Serverless team is aware of the shortcomings since they&amp;rsquo;ve openly discussed
these in their push towards v1.0. Only a few days ago &lt;a href=&#34;http://blog.serverless.com/serverless-v1-0-alpha1-announcement/&#34; target=&#34;_blank&#34;&gt;they announce a beta version of
1.0&lt;/a&gt; which I have yet to try out.&lt;/p&gt;

&lt;p&gt;In any case, as long as you&amp;rsquo;re aware of the issues in v0.5.5 which is what is currently stable you
should have no trouble working around them. With v1.0 being not too far away I suspect very soon
I&amp;rsquo;ll start writing about that system since it appears to be much improved and fundamentally
different in the way it organizing things.&lt;/p&gt;

&lt;p&gt;So, what we&amp;rsquo;ll discuss here is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Syncing sensitive AWS data with the &lt;code&gt;meta sync&lt;/code&gt; plugin&lt;/li&gt;
&lt;li&gt;Working on an existing project after a &lt;code&gt;git clone&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Creating a new API endpoint and function&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;syncing-with-the-meta-sync-plugin&#34;&gt;Syncing with the &lt;code&gt;meta sync&lt;/code&gt; plugin&lt;/h2&gt;

&lt;p&gt;One issue you will quickly run in to when either working on a project with someone else &lt;em&gt;or&lt;/em&gt;
working on your own project on different computers is that of the &lt;code&gt;_meta&lt;/code&gt; directory. If you &lt;a href=&#34;https://github.com/brianz/serverless-demo&#34; target=&#34;_blank&#34;&gt;look at
the repository for this demo project&lt;/a&gt;
you&amp;rsquo;ll notice there isn&amp;rsquo;t a &lt;code&gt;_meta&lt;/code&gt; directory. The reason is
that this directory stores (potentially) sensitive information about your project such as private keys, etc.
By default, Serverless will &lt;a href=&#34;https://github.com/brianz/serverless-demo/blob/part-ii/serverless-demo/.gitignore#L43&#34; target=&#34;_blank&#34;&gt;add &lt;code&gt;_meta&lt;/code&gt; to the &lt;code&gt;.gitignore&lt;/code&gt; of your
project&lt;/a&gt;.
Not only that, different &amp;ldquo;environments&amp;rdquo; (or &amp;ldquo;stages&amp;rdquo; in the world of Lambda) will undoubtedly have
different configuration settings at some point. Imagine an endpoint which needs to talk to DynamoDB
or an SNS topic. Serverless allows us to reference things like this with environment variables
which are injected at deploy time through some &lt;code&gt;_meta&lt;/code&gt; files
(see &lt;a href=&#34;http://blog.brianz.bz/post/serverless-part-iii/&#34; target=&#34;_blank&#34;&gt;part III&lt;/a&gt; to learn about variables).&lt;/p&gt;

&lt;p&gt;What this means is that when you &lt;code&gt;git clone&lt;/code&gt; a repository Serverless won&amp;rsquo;t have a clue what to do
with it.  Any &lt;code&gt;sls&lt;/code&gt; command you issue will result in an error since Serverless doesn&amp;rsquo;t know what
resources to work with.  &lt;strong&gt;This is one area where Serverless needs to improve.&lt;/strong&gt;  I find this part
quite clunky since there are multiple hoops to jump through in order to get a project running
after a simple &lt;code&gt;git clone&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To start, you&amp;rsquo;ll want to use a plugin which will sync your &lt;code&gt;_meta&lt;/code&gt; folder to S3. All this does is give
you a way to (in effect) copy and paste the contents of &lt;code&gt;_meta&lt;/code&gt; between computers in a secure
manner.  The caveat being that users or systems using this will both need to have read/write access
to the designated S3 bucket.  How you manage your AWS keys between systems is an entirely
different discussion which we won&amp;rsquo;t talk about now (and is a question which I&amp;rsquo;m working out myself).&lt;/p&gt;

&lt;p&gt;Setting up &lt;code&gt;meta sync&lt;/code&gt; is pretty simple&amp;hellip;the Github page gives you all the details you&amp;rsquo;ll need:
&lt;a href=&#34;https://github.com/serverless/serverless-meta-sync&#34; target=&#34;_blank&#34;&gt;https://github.com/serverless/serverless-meta-sync&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Someone will need to initially set this up to actually put the &lt;code&gt;_meta&lt;/code&gt; directory up in S3.  If
you&amp;rsquo;re working between different systems and you&amp;rsquo;re the sole developer it&amp;rsquo;ll be pretty easy&amp;hellip;if
you&amp;rsquo;re working on a team the same instructions apply as long as your colleagues have access to the
S3 bucket.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s setup &lt;code&gt;meta sync&lt;/code&gt;. To be crystal clear, this setup only needs to be performed &lt;em&gt;once&lt;/em&gt; by the
original author of the project. After all, the &lt;code&gt;_meta&lt;/code&gt; directory will be created when the project
is first brought to life, so it&amp;rsquo;ll be the responsibility of that first developer to set this up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@1035dd7cffb6:/code$ npm install serverless-meta-sync --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the plugin is installed I just need to update the &lt;code&gt;s-project.json&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;serverless-demo&amp;quot;,
  &amp;quot;custom&amp;quot;: {
    &amp;quot;meta&amp;quot;: {
      &amp;quot;name&amp;quot;: &amp;quot;brianz-cco-serverless-test&amp;quot;,
      &amp;quot;region&amp;quot;: &amp;quot;us-west-2&amp;quot;
    }
  },
  &amp;quot;plugins&amp;quot;: [
    &amp;quot;serverless-meta-sync&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All I&amp;rsquo;m doing is telling the plugin to sync the &lt;code&gt;_meta&lt;/code&gt; directory to an S3 bucket named
&lt;code&gt;brianz-cco-serverless-test&lt;/code&gt; in &lt;code&gt;us-west-2&lt;/code&gt;.  Now that that&amp;rsquo;s done, I issue the sync command&amp;hellip;the
trick here is ensuring you &lt;em&gt;sync for all of your stages and regions&lt;/em&gt;. That&amp;rsquo;s easy to gloss over but
I&amp;rsquo;ll pause here to reemphasize&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;If you have multiple stages for your project you&amp;rsquo;ll need to issue multiple &lt;code&gt;sls
meta sync&lt;/code&gt; commands.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;From part iii of this series I created two stages&amp;hellip;&lt;code&gt;dev&lt;/code&gt; and
&lt;code&gt;production&lt;/code&gt;. I authored that project on my laptop so I&amp;rsquo;ll be doing the following on that computer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@5457e51bf687:/code$ sls meta sync -s dev -r us-west-2
Serverless: Going to sync &amp;quot;s-variables-dev-uswest2.json&amp;quot;... 
Serverless: Creating remote copy of s-variables-dev-uswest2.json...  
Serverless: Done  
root@5457e51bf687:/code$ sls meta sync -s production -r us-west-2
Serverless: Creating remote copy of s-variables-production-uswest2.json...  
Serverless: Done  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the first step in setting yourself up for development on multiple system.&lt;/p&gt;

&lt;h2 id=&#34;setup-a-project-after-git-clone&#34;&gt;Setup a project after &lt;code&gt;git clone&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Now, I switch over to my iMac and clone the repo. You&amp;rsquo;d hope that you&amp;rsquo;d just be able to clone the
repo, install packages, &lt;code&gt;sync&lt;/code&gt; the &lt;code&gt;_meta&lt;/code&gt; folder and you&amp;rsquo;d be done.  You&amp;rsquo;d be wrong.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold$ git clone https://github.com/brianz/serverless-demo.git
brianz@gold$ cd serverless-demo/
brianz@gold(master=)$ ls -l
total 32
-rw-r--r--  1 brianz  staff   182 May 19 09:53 Dockerfile
-rw-r--r--  1 brianz  staff  1081 May 19 09:53 LICENSE
-rwxr-xr-x  1 brianz  staff   174 May 19 09:53 Makefile
-rw-r--r--  1 brianz  staff   411 May 19 09:53 README.md
-rw-r--r--  1 brianz  staff    39 May 31 20:24 config
drwxr-xr-x  7 brianz  staff   238 May 31 20:17 serverless-demo/
brianz@gold(master=)$ cd serverless-demo/
brianz@gold(master=)$ ls -l
total 24
-rw-r--r--  1 brianz  staff   328 May 19 09:53 package.json
-rw-r--r--  1 brianz  staff   190 May 19 09:53 s-project.json
-rw-r--r--  1 brianz  staff  1527 May 19 09:53 s-resources-cf.json
drwxr-xr-x  3 brianz  staff   102 May 19 09:53 src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK&amp;hellip;this is what we expect.  There isn&amp;rsquo;t a &lt;code&gt;_meta&lt;/code&gt; folder. Let&amp;rsquo;s start getting set up and see
what happens (as a reminder I&amp;rsquo;m in a Docker container when running &lt;code&gt;sls&lt;/code&gt; aka &lt;code&gt;serverless&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@bcdeb57d5754:/code$ sls meta sync  
/usr/local/lib/node_modules/serverless/node_modules/bluebird/js/release/async.js:61
        fn = function () { throw arg; };
                           ^

ServerlessError: This plugin could not be found: serverless-meta-sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doh!  We need to install the plugin which makes sense. Since we (or our colleague who setup the
project, aka me on my MBPro) performed an &lt;code&gt;npm install --save&lt;/code&gt; of the plugin it&amp;rsquo;ll be in our &lt;code&gt;package.json&lt;/code&gt;. As with
any node/npm system all we&amp;rsquo;ll need to do is &lt;code&gt;npm install&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@bcdeb57d5754:/code$  npm install
# snip...lots of output
npm info ok 
root@bcdeb57d5754:/code$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have met all our requirements let&amp;rsquo;s try to sync again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@bcdeb57d5754:/code$ sls meta sync 
/usr/local/lib/node_modules/serverless/node_modules/bluebird/js/release/async.js:61
        fn = function () { throw arg; };
                           ^

ServerlessError: No existing stages in the project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hrmmm&amp;hellip;.it&amp;rsquo;s really not that simple. The root cause here is that Serverless still knows nothing of
our project.  Since Serverless works by keeping track of several files in the &lt;code&gt;_meta&lt;/code&gt; directory it
doesn&amp;rsquo;t even know what your project is about&amp;hellip;what resource it needs, nada.  &lt;strong&gt;Serverless should
really make this easier and more intuitive.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;After cloning a repo you will need to perform one or more &lt;code&gt;sls project init&lt;/code&gt; commands&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While the meta-sync plugin will sync your variables files, there are some other files in the
&lt;code&gt;_meta&lt;/code&gt; directory which aren&amp;rsquo;t synced. In order to get that directory and some other non-variable
files bootstrapped and created you&amp;rsquo;ll need to use &lt;code&gt;sls project init&lt;/code&gt;. This can be confusing since
that same command is exactly what you&amp;rsquo;d use to setup a brand new project. Here, because we&amp;rsquo;re
issuing the command in and &lt;em&gt;existing&lt;/em&gt; project, Serverless will setup your &lt;code&gt;_meta&lt;/code&gt; directory and
recreate a few files.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s do it.  Note, you can also pass command line arguments to
speed this up as needed.  Doing a &lt;code&gt;sls project init --help&lt;/code&gt; will show you all of the options you
can use.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@bcdeb57d5754:/code$ sls project init
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v0.5.5
`-------&#39;

Serverless: Initializing Serverless Project...  
Serverless: Enter a new stage name for this project:  (dev) 
Serverless: For the &amp;quot;dev&amp;quot; stage, do you want to use an existing Amazon Web Services profile or
create a new one?
  &amp;gt; Existing Profile
    Create A New Profile
Serverless: Select a profile for your project: 
  &amp;gt; default
Serverless: Creating stage &amp;quot;dev&amp;quot;...  
Serverless: Select a new region for your stage: 
    us-east-1
  &amp;gt; us-west-2
    eu-west-1
    eu-central-1
    ap-northeast-1
Serverless: Creating region &amp;quot;us-west-2&amp;quot; in stage &amp;quot;dev&amp;quot;...  
Serverless: Deploying resources to stage &amp;quot;dev&amp;quot; in region &amp;quot;us-west-2&amp;quot; via Cloudformation (~3
minutes)...  
Serverless: No resource updates are to be performed.  
Serverless: Successfully created region &amp;quot;us-west-2&amp;quot; within stage &amp;quot;dev&amp;quot;  
Serverless: Successfully created stage &amp;quot;dev&amp;quot;  
Serverless: Successfully initialized project &amp;quot;serverless-demo&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold(master=)$ l
total 32
drwxr-xr-x   4 brianz  staff   136 Jun 28 16:58 _meta/
-rw-r--r--   1 brianz  staff    23 Jun 28 16:58 admin.env
drwxr-xr-x  20 brianz  staff   680 Jun 28 16:56 node_modules/
-rw-r--r--   1 brianz  staff   327 Jun 28 16:58 package.json
-rw-r--r--   1 brianz  staff   189 Jun 28 16:58 s-project.json
-rw-r--r--   1 brianz  staff  1527 Jun 28 16:58 s-resources-cf.json
drwxr-xr-x   3 brianz  staff   102 May 19 09:53 src/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voila!  Our &lt;code&gt;_meta&lt;/code&gt; directory is now available.&lt;/p&gt;

&lt;p&gt;At this point, if you inspect any of the &lt;code&gt;variables&lt;/code&gt; files inside &lt;code&gt;_meta/&lt;/code&gt; you&amp;rsquo;ll see that they&amp;rsquo;re
empty.  We&amp;rsquo;re finally at the point where we can pull down our secret variables and config which we
previously synced using meta-sync.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@bcdeb57d5754:/code$ sls meta sync 
Serverless: WARNING: This variable is not defined: magicVariable  
Serverless: WARNING: This variable is not defined: region  
Serverless: WARNING: This variable is not defined: region  
Serverless: Going to sync &amp;quot;s-variables-dev.json&amp;quot;... 
  
 {
+  MY_MAGIC_VARIABLE: &amp;quot;dev&amp;quot;
 }

Serverless: How should these differences be handled?
    Review these changes one by one
  &amp;gt; Apply these changes to the local version
    Discard these changes and sync the remote version with the local one
    Cancel
Serverless: Done 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Excellent&amp;hellip;it finally worked.  At this point we&amp;rsquo;re all set to use the &lt;code&gt;dev&lt;/code&gt; stage.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@bcdeb57d5754:/code$ ls -l _meta/variables/
total 12
-rw-r--r-- 1 1000 staff 34 Jun 28 22:58 s-variables-common.json
-rw-r--r-- 1 1000 staff 27 Jun 28 22:58 s-variables-dev-uswest2.json
-rw-r--r-- 1 1000 staff 50 Jun 28 23:08 s-variables-dev.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s missing? Remember, we have a &amp;ldquo;production&amp;rdquo; stage with it&amp;rsquo;s own variables. That stage&amp;rsquo;s
variables file hasn&amp;rsquo;t been pulled down after our &lt;code&gt;sync&lt;/code&gt;.  &lt;strong&gt;We
need to issue multiple &lt;code&gt;project init&lt;/code&gt; and sync commands for different stages/regions!&lt;/strong&gt; This is
clunky, but at least we only need to do it once per stage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@bcdeb57d5754:/code$ sls project init -s production
Serverless: Initializing Serverless Project...  
Serverless: For the &amp;quot;production&amp;quot; stage, do you want to use an existing Amazon Web Services profile
or create a new one?
  &amp;gt; Existing Profile
    Create A New Profile
Serverless: Select a profile for your project: 
  &amp;gt; default
Serverless: Creating stage &amp;quot;production&amp;quot;...  
Serverless: Select a new region for your stage: 
    us-east-1
  &amp;gt; us-west-2
    eu-west-1
    eu-central-1
    ap-northeast-1
Serverless: Creating region &amp;quot;us-west-2&amp;quot; in stage &amp;quot;production&amp;quot;...  
Serverless: Deploying resources to stage &amp;quot;production&amp;quot; in region &amp;quot;us-west-2&amp;quot; via Cloudformation (~3
minutes)...  
Serverless: No resource updates are to be performed.  
Serverless: Successfully created region &amp;quot;us-west-2&amp;quot; within stage &amp;quot;production&amp;quot;  
Serverless: Successfully created stage &amp;quot;production&amp;quot;  
Serverless: Successfully initialized project &amp;quot;serverless-demo&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve &lt;code&gt;init&#39;ed&lt;/code&gt; the production stage we can finally sync it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@bcdeb57d5754:/code$ sls meta sync -s production
Serverless: WARNING: This variable is not defined: magicVariable  
Serverless: WARNING: This variable is not defined: region  
Serverless: WARNING: This variable is not defined: region  
Serverless: Going to sync &amp;quot;s-variables-production.json&amp;quot;... 
  
 {
+  magicVariable: &amp;quot;Magic production thingie&amp;quot;
 }

Serverless: How should these differences be handled?
    Review these changes one by one
  &amp;gt; Apply these changes to the local version
    Discard these changes and sync the remote version with the local one
    Cancel
Serverless: Done  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phew. In my opinion that&amp;rsquo;s a lot of work to do just to get the project in a state where you can
start working on. I expect and hope this flow to get much easier in Serverless v1.0.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-new-api-endpoint&#34;&gt;Creating a new API endpoint&lt;/h2&gt;

&lt;p&gt;Now that we&amp;rsquo;re set up on a new system let&amp;rsquo;s start the process of creating a new function. A simple
&lt;code&gt;Hello world!&lt;/code&gt; example is quite boring, so what I&amp;rsquo;ll do is create a new endpoint which accepts a
&lt;code&gt;jwt&lt;/code&gt; token in a &lt;code&gt;json&lt;/code&gt; payload validates that it&amp;rsquo;s correct.  To do this, we&amp;rsquo;ll use a 3rd party
Python library and some of our own Python code. This will demonstrate a few things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;how to package requirements&lt;/li&gt;
&lt;li&gt;how to deal with POST data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First we&amp;rsquo;ll create the function and endpoint&amp;hellip;this is a Python 2.7 function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@bcdeb57d5754:/code$ sls function create src/authenticate -r python2.7
Serverless: For this new Function, would you like to create an Endpoint, Event, or just the
Function?
  &amp;gt; Create Endpoint
    Create Event
    Just the Function...
Serverless: Successfully created function: &amp;quot;src/authenticate&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the function and API endpoint are set up we&amp;rsquo;ll actually need to write some some. Crack
open the &lt;code&gt;src/authenticate/handler.py&lt;/code&gt; function if you&amp;rsquo;re following along. You can also &lt;a href=&#34;https://github.com/brianz/serverless-demo/blob/part-iv/serverless-demo/src/authenticate/handler.py&#34; target=&#34;_blank&#34;&gt;look at
the final version on
Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are a few things to note in order to get non-trivial functions like this one working:&lt;/p&gt;

&lt;h3 id=&#34;installing-libraries&#34;&gt;Installing libraries&lt;/h3&gt;

&lt;p&gt;Since we&amp;rsquo;re relying on a &lt;code&gt;jwt&lt;/code&gt; library from a 3rd party we need to send that up to Lambda with our
own function. Serverless does the work of creating a zip file of your code and any supporting
code/libraries and uploading that to Lambda. With Python, we can &amp;ldquo;install&amp;rdquo; any supporting libraries
in a folder next to our application code.  In this example I&amp;rsquo;ll use the &lt;code&gt;lib&lt;/code&gt; directory. &lt;a href=&#34;https://github.com/brianz/serverless-demo/tree/master/serverless-demo/src&#34; target=&#34;_blank&#34;&gt;If you
look at this repo on
Github&lt;/a&gt; you&amp;rsquo;ll see a
&lt;code&gt;requirements.txt&lt;/code&gt; file along with a little helper script to create and populate the &lt;code&gt;lib/&lt;/code&gt;
directory.  Running this script will get the &lt;code&gt;lib/&lt;/code&gt; directory bootstrapped&amp;hellip;only after that is
done will you be able to move on to the next step.  &lt;em&gt;Without&lt;/em&gt; the supporting libraries installed
and uploaded your function will throw an &lt;code&gt;ImportError&lt;/code&gt; and not execute successfully.&lt;/p&gt;

&lt;h3 id=&#34;path-hacking&#34;&gt;Path hacking&lt;/h3&gt;

&lt;p&gt;With our &lt;code&gt;lib/&lt;/code&gt; directory successfully populated and uploaded with our application code we need
to make our application code/Lambda function aware that it exists.  Remember, this is just an
arbitrary directory with Python packages that we&amp;rsquo;re uploading with our main Lambda function&amp;hellip;our
Lambda function/handler has no way of knowing that it should look in this directory for any of its
dependencies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Before&lt;/strong&gt; any imports to 3rd party packages we need to hack the system path ourselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cwd = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(cwd, &amp;quot;../lib&amp;quot;))

# now you can import jwt or anything else you install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty simple&amp;hellip;if you decide to change the name of your directory which holds your dependencies
you&amp;rsquo;ll of course need to change your functions to reference that location.  Also, if you create a
function which is nested any deeper in the package structure you&amp;rsquo;ll have to adjust the
&lt;code&gt;os.path.join&lt;/code&gt; call&amp;hellip;for example if you create a function in &lt;code&gt;authenticate/users/handler.py&lt;/code&gt; that
function would then need to use &lt;code&gt;&amp;quot;../..lib&amp;quot; since it&#39;s two directories away from&lt;/code&gt;lib/`.&lt;/p&gt;

&lt;h3 id=&#34;packaging-lib&#34;&gt;Packaging &lt;code&gt;lib/&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The last thing we need to take care of is instructing Serverless to package up our &lt;code&gt;lib/&lt;/code&gt; directory
with our handler function. This is done by mangling the &lt;code&gt;handler&lt;/code&gt; value in &lt;code&gt;s-function.json&lt;/code&gt;. In
short, all you do it change the path to the handler which you&amp;rsquo;re using. Originally the &lt;code&gt;handler&lt;/code&gt;
value is a simple string, pointing to your handlerfile.handlerfunction like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;    &amp;quot;handler&amp;quot;: &amp;quot;handler.handler&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our change will add in one level to the path to that handler file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;    &amp;quot;handler&amp;quot;: &amp;quot;authenticate/handler.handler&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Serverless will notice this and then package up everything which sits alongside the &lt;code&gt;authenticate&lt;/code&gt;
directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold(master=)$ ls -l
total 16
drwxr-xr-x  5 brianz  staff  170 Jul  1 11:18 authenticate/
-rwxr-xr-x  1 brianz  staff   94 Jun 28 20:46 build-requirements.sh*
drwxr-xr-x  5 brianz  staff  170 Jun 20 16:18 hello/
drwxr-xr-x  4 brianz  staff  136 Jun 28 20:45 lib/
-rw-r--r--  1 brianz  staff   13 Jun 28 20:41 requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything you see here will wind up in our final zip file.&lt;/p&gt;

&lt;h3 id=&#34;extracting-post-body&#34;&gt;Extracting POST body&lt;/h3&gt;

&lt;p&gt;Finally, there&amp;rsquo;s the work of extracting content from the actual &lt;code&gt;POST&lt;/code&gt; body and sending it over to
the Lambda function.  This is handled by API Gateway.  Here&amp;rsquo;s the change/addition in
&lt;code&gt;s-function.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;requestTemplates&amp;quot;: {
  &amp;quot;application/json&amp;quot;: {
    &amp;quot;token&amp;quot;: &amp;quot;$input.json(&#39;$.token&#39;)&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is one of the most confusing parts of API Gateway IMO. This ends up injecting a &lt;code&gt;token&lt;/code&gt; field
into your Lambda &lt;code&gt;event&lt;/code&gt; by extracting the &lt;code&gt;token&lt;/code&gt; field from the expected json payload in the
&lt;code&gt;POST&lt;/code&gt;.  Our Python function can then reference this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;token = event.get(&#39;token&#39;, &#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phew! Let&amp;rsquo;s try this out. Our JWT secret for signing our tokens is simply the string &lt;code&gt;&amp;quot;secret&amp;quot;&lt;/code&gt;.
You can visit &lt;a href=&#34;https://jwt.io&#34; target=&#34;_blank&#34;&gt;https://jwt.io&lt;/a&gt; and generate a new token and try it for yourself. My Lambda function
will simply decode the token and return the results if it&amp;rsquo;s valid. If it&amp;rsquo;s &lt;em&gt;not&lt;/em&gt; valid the Lambda
function will raise an exception which will be returned to you:&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a valid token:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s -d &#39;{&amp;quot;token&amp;quot;: &amp;quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImJyaWFueiIsIm9yaWdfaWF0IjoxNDY3MTMyMTgzLCJleHAiOjE3ODI3NTIzNzIsImVtYWlsIjoiYnJpYW56QGdtYWlsLmNvbSIsInNjb3BlcyI6WyJkZXZlbG9wZXIiLCJzZXJ2ZXJsZXNzLWZhbiJdfQ.tmbOyytr0vbNdaFL0wc31SIpWw8E_xqUIDoWsXYM2do&amp;quot;}&#39; \
https://4m98c4l3i1.execute-api.us-west-2.amazonaws.com/dev/authenticate | python -mjson.tool
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;email&amp;quot;: &amp;quot;brianz@gmail.com&amp;quot;,
    &amp;quot;exp&amp;quot;: 1782752372,
    &amp;quot;orig_iat&amp;quot;: 1467132183,
    &amp;quot;scopes&amp;quot;: [
        &amp;quot;developer&amp;quot;,
        &amp;quot;serverless-fan&amp;quot;
    ],
    &amp;quot;username&amp;quot;: &amp;quot;brianz&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neat! Generated this token by plugging in some arbitrary data at the &lt;a href=&#34;https://jwt.io&#34; target=&#34;_blank&#34;&gt;https://jwt.io&lt;/a&gt; playground. Note
that I pushed the &lt;code&gt;exp&lt;/code&gt; (expires) field far in the future.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try an invalid signature where the &lt;code&gt;exp&lt;/code&gt; field is in the past:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -s -d &#39;{&amp;quot;token&amp;quot;: &amp;quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImJyaWFueiIsIm9yaWdfaWF0IjoxNDY3MTMyMTgzLCJleHAiOjE0NjcyMTk2OTMsImVtYWlsIjoiYnJpYW56QGdtYWlsLmNvbSIsInNjb3BlcyI6WyJkZXZlbG9wZXIiLCJzZXJ2ZXJsZXNzLWZhbiJdfQ.A1UJOKcSfpUSuAgZoBO9g0oBtGdkrl71VtNt4F5eJZg&amp;quot;}&#39; \
https://4m98c4l3i1.execute-api.us-west-2.amazonaws.com/dev/authenticate | python -mjson.tool
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;errorMessage&amp;quot;: &amp;quot;Signature has expired&amp;quot;,
    &amp;quot;errorType&amp;quot;: &amp;quot;ExpiredSignatureError&amp;quot;,
    &amp;quot;stackTrace&amp;quot;: [
        [
            &amp;quot;/var/task/authenticate/handler.py&amp;quot;,
            30,
            &amp;quot;handler&amp;quot;,
            &amp;quot;decoded = jwt_decode_handler(token)&amp;quot;
        ],
        [
            &amp;quot;/var/task/authenticate/handler.py&amp;quot;,
            21,
            &amp;quot;jwt_decode_handler&amp;quot;,
            &amp;quot;return jwt.decode(token, JWT_SECRET_KEY)&amp;quot;
        ],
        [
            &amp;quot;/var/task/authenticate/../lib/jwt/api_jwt.py&amp;quot;,
            75,
            &amp;quot;decode&amp;quot;,
            &amp;quot;self._validate_claims(payload, merged_options, **kwargs)&amp;quot;
        ],
        [
            &amp;quot;/var/task/authenticate/../lib/jwt/api_jwt.py&amp;quot;,
            104,
            &amp;quot;_validate_claims&amp;quot;,
            &amp;quot;self._validate_exp(payload, now, leeway)&amp;quot;
        ],
        [
            &amp;quot;/var/task/authenticate/../lib/jwt/api_jwt.py&amp;quot;,
            149,
            &amp;quot;_validate_exp&amp;quot;,
            &amp;quot;raise ExpiredSignatureError(&#39;Signature has expired&#39;)&amp;quot;
        ]
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty cool. And how about a missing token?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s -X POST https://4m98c4l3i1.execute-api.us-west-2.amazonaws.com/dev/authenticate | python -mjson.tool
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;errorMessage&amp;quot;: &amp;quot;Mission token&amp;quot;,
    &amp;quot;errorType&amp;quot;: &amp;quot;Exception&amp;quot;,
    &amp;quot;stackTrace&amp;quot;: [
        [
            &amp;quot;/var/task/authenticate/handler.py&amp;quot;,
            27,
            &amp;quot;handler&amp;quot;,
            &amp;quot;raise Exception(&#39;Mission token&#39;)&amp;quot;
        ]
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you were doing this for real you&amp;rsquo;d want to handle failures more gracefully.  With API Gateway
you can match on certain responses to control HTTP return codes. Of course, you&amp;rsquo;d also want to hide
the details of the stack blowing up and instead return some nicer error messages.&lt;/p&gt;

&lt;p&gt;That was a big post&amp;hellip;hopefully this gives  you some idea on how to use Serverless for a &lt;em&gt;real&lt;/em&gt;
application. I&amp;rsquo;ll continue developing this series and I&amp;rsquo;m sure there will be updates as Serverless
v1.0 evolves!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serverless part III</title>
      <link>http://blog.brianz.bz/post/serverless-part-iii/</link>
      <pubDate>Thu, 02 Jun 2016 17:01:36 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/serverless-part-iii/</guid>
      <description>

&lt;p&gt;This is part three in my series about creating serverless systems using AWS API Gateway + Lambda
via the &lt;a href=&#34;http://serverless.com&#34; target=&#34;_blank&#34;&gt;Serverless&lt;/a&gt; project. If you&amp;rsquo;re haven&amp;rsquo;t already you can read
&lt;a href=&#34;http://blog.brianz.bz/post/serverless-part-i/&#34; target=&#34;_blank&#34;&gt;part I&lt;/a&gt; and &lt;a href=&#34;http://blog.brianz.bz/post/serverless-part-ii/&#34; target=&#34;_blank&#34;&gt;part II&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My goal is to continue evolving this example to walk through a non-trivial example of doing
something with the serverless architecture. Along the way I&amp;rsquo;ll demo some useful features which
you&amp;rsquo;ll undoubtedly run into when doing real development with Serverless.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll be covering two topics in this post:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;API Gateway Stages&lt;/li&gt;
&lt;li&gt;Managing configuration with variables&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;api-gateway-stages&#34;&gt;API Gateway Stages&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re new to API Gateway and Lambda an obvious question you may ask is, &amp;ldquo;How do I setup
different deployments for my Serverless system?&amp;rdquo;  Coming from a traditional setup most everyone
will spin up different stacks/servers for their QA, Staging and Production environments.  However,
with a serverless project, how to you go about the same thing?&lt;/p&gt;

&lt;p&gt;The answer to this are API Gateway stages. &lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/stages.html&#34; target=&#34;_blank&#34;&gt;You can read the
docs&lt;/a&gt; but I&amp;rsquo;ll try to
distill down the big concepts&amp;hellip;it&amp;rsquo;s not that complicated to grok.&lt;/p&gt;

&lt;p&gt;With Gateway, a Stage is analogous to an &amp;ldquo;environment&amp;rdquo; if you&amp;rsquo;re running your own system.  For
example, in a given AWS account you may want to run and manage your Serverless project as one unit
but manage your QA and Production environments separately.  Of course, any new code or
configuration changes you would first deploy to your QA Stage. Once you were confident things were
working you&amp;rsquo;d then roll out those same changes to your Production Stage.  Again, the analogy here
is that you&amp;rsquo;re deploying code to different and separate systems.  Another scenario is multiple
developers working on the same project&amp;hellip;each developer could have their own stage which would
eliminate stepping on each other while doing development.  API Gateway gives us this ability
(and more) via Stages.&lt;/p&gt;

&lt;p&gt;By default, you&amp;rsquo;ll get a &lt;code&gt;dev&lt;/code&gt; stage when setting up a new Serverless project. Let&amp;rsquo;s create a new
stage which we&amp;rsquo;ll call &lt;code&gt;production&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Remember, I&amp;rsquo;m using a Docker container to execute all of my Serverless commands.  You can follow
along by &lt;a href=&#34;https://github.com/brianz/serverless-demo/tree/part-iii&#34; target=&#34;_blank&#34;&gt;checking out the repository&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold(master=)$ make shell
docker run --rm -it \
        -v `pwd`:/code \
        --name=slsdemo &amp;quot;bz/serverless&amp;quot; bash
root@8941047f877c:/code# 
root@7c84db71d474:/code/serverless-demo$ sls stage create   
Serverless: Enter a new stage name for this project:  (dev) production
Serverless: For the &amp;quot;production&amp;quot; stage, do you want to use an existing Amazon Web Services profile
or create a new one?
  &amp;gt; Existing Profile
    Create A New Profile
Serverless: Select a profile for your project: 
  &amp;gt; default
Serverless: Creating stage &amp;quot;production&amp;quot;...  
Serverless: Select a new region for your stage: 
    us-east-1
  &amp;gt; us-west-2
    eu-west-1
    eu-central-1
    ap-northeast-1
Serverless: Creating region &amp;quot;us-west-2&amp;quot; in stage &amp;quot;production&amp;quot;...  
Serverless: Deploying resources to stage &amp;quot;production&amp;quot; in region &amp;quot;us-west-2&amp;quot; via Cloudformation (~3 minutes)...  
Serverless: Successfully deployed &amp;quot;production&amp;quot; resources to &amp;quot;us-west-2&amp;quot;  
Serverless: Successfully created region &amp;quot;us-west-2&amp;quot; within stage &amp;quot;production&amp;quot;  
Serverless: Successfully created stage &amp;quot;production&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! Remembering back, creating this new stage is akin to creating a new project.  We don&amp;rsquo;t
actually have anything behind the scenes&amp;hellip;we just have scaffolding in place so that we can deploy
some stuff.  So, let&amp;rsquo;s deploy our existing &lt;code&gt;hello&lt;/code&gt; function and endpoint:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@7c84db71d474:/code/serverless-demo$ sls dash deploy
Serverless: Select the assets you wish to deploy:
    hello
      &amp;gt; function - hello
      &amp;gt; endpoint - hello - GET
    - - - - -
  &amp;gt; Deploy
    Cancel

Serverless: Choose a Stage: 
    1) dev
  &amp;gt; 2) production
Serverless: Deploying the specified functions in &amp;quot;production&amp;quot; to the following regions: us-west-2  
Serverless: ------------------------  
Serverless: Successfully deployed the following functions in &amp;quot;production&amp;quot; to the following regions:   
Serverless: us-west-2 ------------------------  
Serverless:   hello (serverless-demo-hello):
arn:aws:lambda:us-west-2:123874195435:function:serverless-demo-hello:production  

Serverless: Deploying endpoints in &amp;quot;production&amp;quot; to the following regions: us-west-2  
Serverless: Successfully deployed endpoints in &amp;quot;production&amp;quot; to the following regions:  
Serverless: us-west-2 ------------------------  
Serverless:   GET - hello - https://4m98c4l3i1.execute-api.us-west-2.amazonaws.com/production/hello  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above, note that I&amp;rsquo;m deploying to the &lt;code&gt;production&lt;/code&gt; stage.  Down below Serverless spit out a new URL
which we can use to hit.&lt;/p&gt;

&lt;p&gt;Behind the scenes, what is actually happening is that Serverless is instruction API Gateway and
Lambda to do several things&amp;hellip;one of which is creating new versions of your Lambda function. Once
the new Lambda version is available, API Gateway will be pointed to that new version via a Lambda
Alias.  API Gateway has a notion of a Stage Variable. As an example, our &lt;code&gt;production&lt;/code&gt; stage will
have a Stage Variable of &lt;code&gt;functionAlias = production&lt;/code&gt;.  That means that this stage will point to
the &lt;code&gt;production&lt;/code&gt; alias of our lambda function.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s quite interesting how it&amp;rsquo;s all orchestrated and I&amp;rsquo;d recommend &lt;a href=&#34;http://docs.serverless.com/docs/workflow#deploying-your-functions&#34; target=&#34;_blank&#34;&gt;reading the
Serverless docs&lt;/a&gt; and playing
around to see for yourself what changes in the AWS console as you deploy code.&lt;/p&gt;

&lt;h2 id=&#34;managing-configuration-with-variables&#34;&gt;Managing configuration with variables&lt;/h2&gt;

&lt;p&gt;Now that we have two different stages let&amp;rsquo;s show that they are indeed separated and can be
controlled independently. What we&amp;rsquo;ll do is actually print out the name of the stage from our Lambda function.
This is really easy to do thanks to &lt;a href=&#34;http://docs.serverless.com/docs/function-configuration&#34; target=&#34;_blank&#34;&gt;Serverless variables&lt;/a&gt;.  These are settings
which can be unique for a given deployment&amp;hellip;think about a database username, an API key for a 3rd
party system, etc. When rolling out different versions of your code you&amp;rsquo;ll inevitably require each
one to use specific settings.&lt;/p&gt;

&lt;p&gt;Crack open &lt;code&gt;s-function.json&lt;/code&gt; and grep for &lt;code&gt;environment&lt;/code&gt;&amp;hellip;you&amp;rsquo;ll see that Serverless is referencing
three different environment variables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;environment&amp;quot;: {
    &amp;quot;SERVERLESS_PROJECT&amp;quot;: &amp;quot;${project}&amp;quot;,
    &amp;quot;SERVERLESS_STAGE&amp;quot;: &amp;quot;${stage}&amp;quot;,
    &amp;quot;SERVERLESS_REGION&amp;quot;: &amp;quot;${region}&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are simple key/value pairs which Serverless will send over to Lamda when doing a
deployment. Here, the &amp;ldquo;values&amp;rdquo; are being referenced by some magic serverless variables with the
&lt;code&gt;${thing}&lt;/code&gt; syntax.  What is actually populating the values?  The answer lies in the &lt;code&gt;_meta&lt;/code&gt;
directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold(master=)$ ls -l
total 40
-rw-r--r--  1 brianz  staff   34 Jun  2 15:22 s-variables-common.json
-rw-r--r--  1 brianz  staff  220 Jun  2 15:22 s-variables-dev-uswest2.json
-rw-r--r--  1 brianz  staff   50 Jun  2 15:22 s-variables-dev.json
-rw-r--r--  1 brianz  staff  234 Jun  2 15:27 s-variables-production-uswest2.json
-rw-r--r--  1 brianz  staff   27 Jun  2 15:25 s-variables-production.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see here that for each stage we have two different files. The files with the region name
contains some meta data about our deployments&amp;hellip;for now, we&amp;rsquo;re more interested in the
&lt;code&gt;s-variables-production.json&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold(master=)$ grep stage *
s-variables-dev.json:  &amp;quot;stage&amp;quot;: &amp;quot;dev&amp;quot;,
s-variables-production.json:  &amp;quot;stage&amp;quot;: &amp;quot;production&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, the &lt;code&gt;stage&lt;/code&gt; variable is automatically set in these files.&lt;/p&gt;

&lt;p&gt;Now, you may think that these variables are being set and uploaded to AWS somewhere via Stage
Variables or the like. I definitely thought that&amp;hellip;but I was wrong. Environment variables which you
define and use in Serverless like this are actually injected into your Lambda handler upon
deployment.  You can &lt;a href=&#34;http://docs.serverless.com/docs/workflow#deploying-your-functions&#34; target=&#34;_blank&#34;&gt;read all about it in the Serverless
docs&lt;/a&gt;. The key is this single
bullet point:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Your regular handler file is replaced by one that Serverless adds titled _serverless_handler, which
contains your Function&amp;rsquo;s Environment Variables in-lined in the code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Serverless actually gives us a &lt;em&gt;new&lt;/em&gt; Lambda handler with the environment variables injected to
&lt;code&gt;os.environ&lt;/code&gt; before calling our &lt;a href=&#34;https://github.com/brianz/serverless-demo/blob/cccda988e257423348c87c87983a4f7c4add401d/serverless-demo/src/hello/handler.py#L12&#34; target=&#34;_blank&#34;&gt;Python handler&lt;/a&gt;.
.Getting access to the values is quite easy&amp;hellip;it&amp;rsquo;s just the stock Python way of getting stuff from
the environment Here&amp;rsquo;s the change we&amp;rsquo;ll make to get the stage name and return it in the HTML message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def handler(event, context):
    value = os.environ.get(&#39;SERVERLESS_STAGE&#39;, &#39;&#39;)
    return &amp;quot;&amp;quot;&amp;quot;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;Hello from Serverless/API Gateway/Lambda&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;SERVERLESS_STAGE: %s&amp;lt;/h2&amp;gt;
        &amp;lt;h2&amp;gt;Event:&amp;lt;/h2&amp;gt;
        &amp;lt;pre&amp;gt;
            %s
        &amp;lt;/pre&amp;gt;
        &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;&amp;quot;&amp;quot;&amp;quot; % (value, json.dumps(event), )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once that&amp;rsquo;s done I&amp;rsquo;ll &lt;code&gt;sls dash deploy&lt;/code&gt; for the &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;production&lt;/code&gt; stages&amp;hellip;low and behold,
when I hit the two endpoint I get what I expect:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.brianz.bz/images/serverless-demo-dev.png&#34; width=&#34;800&#34;&gt;
&lt;img src=&#34;http://blog.brianz.bz/images/serverless-demo-production.png&#34; width=&#34;800&#34;&gt;&lt;/p&gt;

&lt;p&gt;I think it&amp;rsquo;s interesting to look behind the scenes to see how this actually happened. When you
download the zip file containing your code which backs your lambda function you&amp;rsquo;ll see what your
rewritten handler actually looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold(master=)$ cat ~/Desktop/serverless-demo-hello-5b5a957b-4073-43fd-8b76-d315422fd269/_serverless_handler.py 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os, sys
os.environ[&#39;SERVERLESS_PROJECT&#39;] = str(&#39;serverless-demo&#39;)
os.environ[&#39;SERVERLESS_STAGE&#39;] = str(&#39;dev&#39;)
os.environ[&#39;SERVERLESS_REGION&#39;] = str(&#39;us-west-2&#39;)
os.environ[&#39;SERVERLESS_DATA_MODEL_STAGE&#39;] = str(&#39;dev&#39;)
here = os.path.dirname(os.path.realpath(__file__))
sys.path.append(here)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great&amp;hellip;we now know how to access environment variables and control deployments via stages. Let&amp;rsquo;s
do the work of adding some configuration of our own!&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to add another reference in &lt;code&gt;handler.py&lt;/code&gt; to a new variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;magic = os.environ.get(&#39;MAGIC_VARIABLE&#39;, &#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other small change is simply putting it in the HTML output string.  I also will need to inject
this variable into the lambda function by adding it to &lt;code&gt;s-function.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;environment&amp;quot;: {
    &amp;quot;MAGIC_VARIABLE&amp;quot;: &amp;quot;${magicVariable}&amp;quot;,
    // existing vars
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is setting these variable. Note here, we have a &lt;em&gt;single&lt;/em&gt; change to
&lt;code&gt;s-function.json&lt;/code&gt;&amp;hellip;it&amp;rsquo;s getting the actual value for &lt;code&gt;MAGIC_VARIABLE&lt;/code&gt; from the Serverless
framework.  We can control the value of &lt;code&gt;${magicVariable}&lt;/code&gt; by hooking into Serverless
configuration/variable files.  I&amp;rsquo;m going to add two different values&amp;hellip;one for each of our two
deployments. Open up &lt;code&gt;s-variables-production.json&lt;/code&gt; and &lt;code&gt;s-variables-dev.json&lt;/code&gt;. The &lt;code&gt;dev&lt;/code&gt; version
turns into this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;magicVariable&amp;quot;: &amp;quot;Not secret or important&amp;quot;,
  &amp;quot;stage&amp;quot;: &amp;quot;dev&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The production file has the same variable but of course with a different value.  Now let&amp;rsquo;s deploy
both of these and see what we get:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dev&lt;/code&gt;
&lt;img src=&#34;http://blog.brianz.bz/images/serverless-demo-magic-var-dev.png&#34; width=&#34;800&#34;&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip;and, &lt;code&gt;production&lt;/code&gt;
&lt;img src=&#34;http://blog.brianz.bz/images/serverless-demo-magic-var-production.png&#34; width=&#34;800&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We now know how to create different deployments and control them independently. I also explained
some of the voodoo going on behind the scenes. In Part IV I&amp;rsquo;ll cover some other features in the
Serverless ecosystem which allows for easier collaboration and syncing of sensitive data.
Hopefully, we can also start building out a more interesting demo which actually does something.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serverless part II</title>
      <link>http://blog.brianz.bz/post/serverless-part-ii/</link>
      <pubDate>Mon, 02 May 2016 22:08:40 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/serverless-part-ii/</guid>
      <description>

&lt;p&gt;Following up from my &lt;a href=&#34;http://blog.brianz.bz/post/serverless-part-i/&#34; target=&#34;_blank&#34;&gt;last post about serverless&lt;/a&gt; systems, let&amp;rsquo;s do
a walk-through of the &lt;a href=&#34;http://serverless.com&#34; target=&#34;_blank&#34;&gt;Serverless&lt;/a&gt; project.&lt;/p&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting started&lt;/h2&gt;

&lt;p&gt;As usual I&amp;rsquo;ll demo this using a Docker container. You can check out the code on Github and follow
along: &lt;a href=&#34;https://github.com/brianz/serverless-demo&#34; target=&#34;_blank&#34;&gt;https://github.com/brianz/serverless-demo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This Docker image has Serverless v0.5.5&amp;hellip;and that&amp;rsquo;s about it.
I use a basic &lt;code&gt;Makefile&lt;/code&gt; to build and run the container. You can take a
look at it yourself and change the container name if you&amp;rsquo;d like to follow along.&lt;/p&gt;

&lt;p&gt;I also recommend reading the &lt;a href=&#34;http://docs.serverless.com/docs/configuring-aws&#34; target=&#34;_blank&#34;&gt;getting started docs on the serverless
website&lt;/a&gt;, perhaps in parallel with this blog post
in case I have missed any details.&lt;/p&gt;

&lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re following along, you should create two files alongside the Makefile:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;credentials&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These two files will be copied to &lt;code&gt;/root/.aws/&lt;/code&gt; when you build the Docker image.&lt;/p&gt;

&lt;p&gt;These should have the following contents which will be specific to you:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;credentials&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[default]
aws_access_key_id=YOUR_AWS_ACCESS_KEY
aws_secret_access_key=YOUR_AWS_SECRET_KEY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[default]
region=YOUR_PREFERRED_REGION(ex. us-west-2)
output=json
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;really-getting-started&#34;&gt;Really getting started&lt;/h2&gt;

&lt;p&gt;With that out of the way, fire up your container and let&amp;rsquo;s take this for a spin. To build the
container just type &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@bz-cconline(master)$ make
brianz@bz-cconline(master)$ # lots of output
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that you can start the container with &lt;code&gt;make shell&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@bz-cconline(master)$ make shell
docker run --rm -it \
        -v `pwd`:/code \
        --name=slsdemo &amp;quot;bz/serverless&amp;quot; bash
root@8b733bf6a50a:/code# 
root@ea44710fc5db:/code# sls --version
0.5.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the code in this directory is being mapped to &lt;code&gt;/code&lt;/code&gt; on the container. This is one of
my favorite Docker tricks and will help here since anything we do with the &lt;code&gt;serverless&lt;/code&gt; or &lt;code&gt;sls&lt;/code&gt;
commands will write files to our &lt;em&gt;local&lt;/em&gt; file system but be visible in the running container.
Serverless is largely/completely controlled by writing and reading files on the local file system.
By mapping the &lt;code&gt;/code&lt;/code&gt; directory on the Docker container to our host system&amp;rsquo;s we&amp;rsquo;re ensured we
won&amp;rsquo;t lose all of our work/files when we stop the container.&lt;/p&gt;

&lt;h2 id=&#34;starting-a-project&#34;&gt;Starting a project&lt;/h2&gt;

&lt;p&gt;We can now start setting up a new serverless project. It&amp;rsquo;s
important to understand that Serverless is coordinating &lt;em&gt;both&lt;/em&gt; AWS API Gateway and AWS Lambda for
us. When executing commands with Serverless it may be hard to know exactly what&amp;rsquo;s being done behind
the scenes. I&amp;rsquo;d recommend looking at both API Gateway and Lambda in the AWS Console to see what
affect your commands have on those services.&lt;/p&gt;

&lt;p&gt;The first thing we&amp;rsquo;ll do is create a new project which will bootstrap the entire project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@48f5e89483ac:/code$ serverless project create
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v0.5.5
`-------&#39;

Serverless: Initializing Serverless Project...  
Serverless: Enter a name for this project:  (serverless-rjdqri) serverless-demo
Serverless: Enter a new stage name for this project:  (dev) 
Serverless: For the &amp;quot;dev&amp;quot; stage, do you want to use an existing Amazon Web Services profile or
create a new one?
  &amp;gt; Existing Profile
    Create A New Profile
Serverless: Select a profile for your project: 
  &amp;gt; default
Serverless: Creating stage &amp;quot;dev&amp;quot;...  
Serverless: Select a new region for your stage: 
    us-east-1
  &amp;gt; us-west-2
    eu-west-1
    eu-central-1
    ap-northeast-1
Serverless: Creating region &amp;quot;us-west-2&amp;quot; in stage &amp;quot;dev&amp;quot;...  
Serverless: Deploying resources to stage &amp;quot;dev&amp;quot; in region &amp;quot;us-west-2&amp;quot; via Cloudformation (~3
minutes)...  
Serverless: No resource updates are to be performed.  
Serverless: Successfully created region &amp;quot;us-west-2&amp;quot; within stage &amp;quot;dev&amp;quot;  
Serverless: Successfully created stage &amp;quot;dev&amp;quot;  
Serverless: Successfully initialized project &amp;quot;serverless-demo&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should be noted that the the step asking about the AWS Profile (where I select &amp;ldquo;Existing
Profile&amp;rdquo;) was reading from our previously configured
&lt;code&gt;credentials&lt;/code&gt; file. You could also bypass this step and instead type in your AWS credentials by
selecting &lt;code&gt;Create A New Profile&lt;/code&gt;. This will save your AWS credentials in a filed named &lt;code&gt;admin.env&lt;/code&gt;.
Setting up profiles the &lt;code&gt;admin.env&lt;/code&gt; file instead references your named profile stored in your home
directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@48f5e89483ac:/code/serverless-demo$ cat admin.env 
AWS_DEV_PROFILE=defaultroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so what just happened?  Let&amp;rsquo;s take it slow&amp;hellip;.a new project folder will now exist which is the
name of your project. From now on you&amp;rsquo;ll need to be in this directory when executing any
&lt;code&gt;serverless&lt;/code&gt; commands (or the alias, &lt;code&gt;sls&lt;/code&gt;). Let&amp;rsquo;s have a look inside:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@c477313ae84f:/code$ cd serverless-demo/
root@c477313ae84f:/code/serverless-demo$ ls -l
total 16
drwxr-xr-x 1 1000 staff  136 Apr 18 22:46 _meta
-rw-r--r-- 1 1000 staff   35 Apr 18 22:46 admin.env
-rw-r--r-- 1 1000 staff  287 Apr 18 22:45 package.json
-rw-r--r-- 1 1000 staff   64 Apr 18 22:45 s-project.json
-rw-r--r-- 1 1000 staff 1527 Apr 18 22:45 s-resources-cf.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what exactly are all of these files? Serverless works by creating and reading files on your
local system.  These files server different purposes but in the end are used to compose API calls
to Amazon. For example, have a look at &lt;code&gt;s-resource-cf.json&lt;/code&gt;&amp;hellip;this is the Cloudformation template
which Serverless used to create various resources for you. By looking at it, you can see exactly
what &lt;code&gt;serverless create project&lt;/code&gt; actually did.  As you can see, we don&amp;rsquo;t have much now other than
some IAM stuff. If you browse the AWS console you will see that there is a Cloudformation stack
matching what you see in &lt;code&gt;s-resources-cf.json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;re bootstrapped let&amp;rsquo;s get to something more fun.&lt;/p&gt;

&lt;h2 id=&#34;create-a-function-and-endpoint&#34;&gt;Create a function and endpoint&lt;/h2&gt;

&lt;p&gt;Next up, we need to actually create a Lambda function. Again, remember that at this point we really
have nothing to use..just some IAM roles.&lt;/p&gt;

&lt;p&gt;Your source code can go anywhere really&amp;hellip;but what I&amp;rsquo;ll do here is create a &lt;code&gt;lib&lt;/code&gt; directory to hold
any library dependencies (which we&amp;rsquo;ll use later) and a &lt;code&gt;src&lt;/code&gt; directory which is where we&amp;rsquo;ll put our
own source code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@c477313ae84f:/code/serverless-demo$ mkdir lib src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we&amp;rsquo;re ready to create our own Lambda function which will be a Python 2.7 function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@c477313ae84f:/code/serverless-demo$ sls function create src/hello
Serverless: Please, select a runtime for this new Function
    nodejs4.3
  &amp;gt; python2.7
    nodejs (v0.10, soon to be deprecated)
Serverless: For this new Function, would you like to create an Endpoint, Event, or just the
Function?
  &amp;gt; Create Endpoint
    Create Event
    Just the Function...
Serverless: Successfully created function: &amp;quot;src/hello&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last question isn&amp;rsquo;t quite intuitive. What exactly is serverless asking you?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Create Endpoint&lt;/code&gt;: Will create &lt;em&gt;both&lt;/em&gt; an API Gateway endpoint plus the Lambda function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Create Event&lt;/code&gt;: Will create a Lambda function which is setup to be triggered on a schedule or
from another type of event (&lt;strong&gt;not&lt;/strong&gt; from API Gateway)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Just the Function...&lt;/code&gt;: Will create &lt;em&gt;just&lt;/em&gt; the Lambda function leaving it up to you to setup
how/when it&amp;rsquo;s triggered&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, we have some Python code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@c477313ae84f:/code/serverless-demo$ ls -l src/hello/
total 12
-rw-r--r-- 1 1000 staff    2 Apr 18 22:53 event.json
-rw-r--r-- 1 1000 staff  226 Apr 18 22:53 handler.py
-rw-r--r-- 1 1000 staff 1198 Apr 18 22:53 s-function.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Have a look at the code in &lt;code&gt;handler.py&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from __future__ import print_function

import json
import logging

log = logging.getLogger()
log.setLevel(logging.DEBUG)

def handler(event, context):
    log.debug(&amp;quot;Received event {}&amp;quot;.format(json.dumps(event)))
    return {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re unfamiliar with Lambda just know that you:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create a function which accepts two params, &lt;code&gt;event&lt;/code&gt; and &lt;code&gt;context&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;map the name of the file/function when creating the Lambda so Lambda knows what to execute&lt;/li&gt;
&lt;li&gt;can use any library you need provided you can zip it up in a single zip file and upload it to
Lambda&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This function is a bit boring&amp;hellip;let&amp;rsquo;s change the return value to be more fun:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# stuff
return {&#39;message&#39;: &#39;Serverless is the future!&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, for the curious browse over to the AWS Lambda page in the AWS Console.  Note, &lt;strong&gt;your new hello
function isn&amp;rsquo;t there!&lt;/strong&gt;.  Why is this?  Well, Serverless has just set things up for you on your
local system but you haven&amp;rsquo;t pushed it to AWS yet.&lt;/p&gt;

&lt;p&gt;To get your code running, we need to &lt;em&gt;deploy&lt;/em&gt; it.&lt;/p&gt;

&lt;h2 id=&#34;deploying-an-endpoint&#34;&gt;Deploying an endpoint&lt;/h2&gt;

&lt;p&gt;Now for the fun part&amp;hellip;we&amp;rsquo;re going to tell Serverless to package up our code, upload it to Lambda
and create us a new endpoint with API Gateway.  Sounds complicated and indeed, if you did this by
hand there are several clicks and &lt;code&gt;zip&lt;/code&gt; commands to take care of. Let&amp;rsquo;s see how easy it is with
Serverless.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@3ce920c5854d:/code/serverless-demo$ sls dash deploy
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v0.5.5
`-------&#39;

Use the &amp;lt;up&amp;gt;, &amp;lt;down&amp;gt;, &amp;lt;pageup&amp;gt;, &amp;lt;pagedown&amp;gt;, &amp;lt;home&amp;gt;, and &amp;lt;end&amp;gt; keys to navigate.
Press &amp;lt;enter&amp;gt; to select/deselect, or &amp;lt;space&amp;gt; to select/deselect and move down.
Press &amp;lt;ctrl&amp;gt; + a to select all, and &amp;lt;ctrl&amp;gt; + d to deselect all.
Press &amp;lt;ctrl&amp;gt; + f to select all functions, and &amp;lt;ctrl&amp;gt; + e to select all endpoints.
Press &amp;lt;ctrl&amp;gt; + &amp;lt;enter&amp;gt; to immediately deploy selected.
Press &amp;lt;escape&amp;gt; to cancel.


Serverless: Select the assets you wish to deploy:
    hello
      function - hello
      endpoint - hello - GET
    - - - - -
  &amp;gt; Deploy
    Cancel

Serverless: Deploying the specified functions in &amp;quot;dev&amp;quot; to the following regions: us-west-2  
Serverless: ------------------------  
Serverless: Successfully deployed the following functions in &amp;quot;dev&amp;quot; to the following regions:   
Serverless: us-west-2 ------------------------  
Serverless:   hello (serverless-demo-hello):
arn:aws:lambda:us-west-2:123874195435:function:serverless-demo-hello:dev  

Serverless: Deploying endpoints in &amp;quot;dev&amp;quot; to the following regions: us-west-2  
Serverless: Successfully deployed endpoints in &amp;quot;dev&amp;quot; to the following regions:  
Serverless: us-west-2 ------------------------  
Serverless:   GET - hello - https://4m98c4l3i1.execute-api.us-west-2.amazonaws.com/dev/hello 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can&amp;rsquo;t see it in the syntax highlighting above, but it&amp;rsquo;s important to deploy &lt;strong&gt;both&lt;/strong&gt; the
&lt;code&gt;function&lt;/code&gt; and the &lt;code&gt;endpoint&lt;/code&gt;.  Here&amp;rsquo;s how that breaks down and what those two things means:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function&lt;/code&gt;: Upload your &lt;code&gt;hello.py&lt;/code&gt; function to Lambda. Serverless takes care of the packaging,
upload, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;endpoint&lt;/code&gt;: Create/update the API Gateway endpoint which will be responsible for calling the
&lt;code&gt;hello.py&lt;/code&gt; function&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With that we get a URL&amp;hellip;let&amp;rsquo;s test it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@bz-cconline(master)$ curl https://4m98c4l3i1.execute-api.us-west-2.amazonaws.com/dev/hello &amp;amp;&amp;amp; echo
{&amp;quot;message&amp;quot;: &amp;quot;Serverless is the future!&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice!  You can see that it just returns a our fun message, but hot damned, it worked! Let&amp;rsquo;s add a
&lt;code&gt;-v&lt;/code&gt; to see the details from the request:o&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@bz-cconline(master)$ curl -v https://4m98c4l3i1.execute-api.us-west-2.amazonaws.com/dev/hello &amp;amp;&amp;amp; echo
*   Trying 54.192.137.191...
* Connected to 4m98c4l3i1.execute-api.us-west-2.amazonaws.com (54.192.137.191) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
* Server certificate: *.execute-api.us-west-2.amazonaws.com
* Server certificate: Symantec Class 3 Secure Server CA - G4
* Server certificate: VeriSign Class 3 Public Primary Certification Authority - G5
&amp;gt; GET /dev/hello HTTP/1.1
&amp;gt; Host: 4m98c4l3i1.execute-api.us-west-2.amazonaws.com
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json;charset=UTF-8
&amp;lt; Content-Length: 40
&amp;lt; Connection: keep-alive
&amp;lt; Date: Tue, 03 May 2016 02:47:27 GMT
&amp;lt; x-amzn-RequestId: 5f2a649a-10d9-11e6-b880-9737ae2ed884
&amp;lt; X-Cache: Miss from cloudfront
&amp;lt; Via: 1.1 b67f54b549c6579a21be3a5a67642d7a.cloudfront.net (CloudFront)
&amp;lt; X-Amz-Cf-Id: 8SqEhohANyUqXGf-uvv9_-dsJLU2SZBvAHCrU1B1d3sIqARCt-weuQ==
&amp;lt; 
* Connection #0 to host 4m98c4l3i1.execute-api.us-west-2.amazonaws.com left intact
{&amp;quot;message&amp;quot;: &amp;quot;Serverless is the future!&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that our &lt;code&gt;Content-Type&lt;/code&gt; header is being returned as &lt;code&gt;application/json;charset=UTF-8&lt;/code&gt;. This
works quite well for us in this case since our Lambda function returned a Python dictionary and
apparently it&amp;rsquo;s getting cast to a JSON object somewhere along the way. Here is where the details of
API Gateway come into play.  Let&amp;rsquo;s assume we wanted our API to return HTML&amp;hellip;how would we do that?&lt;/p&gt;

&lt;h2 id=&#34;update-and-deploy-a-function&#34;&gt;Update and deploy a function&lt;/h2&gt;

&lt;p&gt;With our goal of returning HTML, let&amp;rsquo;s update our function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def handler(event, context):
    return &amp;quot;&amp;quot;&amp;quot;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;Hello from Serverless/API Gateway/Lambda&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;Event:&amp;lt;/h2&amp;gt;
        &amp;lt;pre&amp;gt;
            %s
        &amp;lt;/pre&amp;gt;
        &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;&amp;quot;&amp;quot;&amp;quot; % (json.dumps(event), )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we&amp;rsquo;ll do now is deploy this. Note, the analogy here is rolling out new code. Think about how
complicated that normally is with a traditional web application.  Undoubtedly there are scripts,
CI systems and the like who are tasked with rolling out your new code. Here, we&amp;rsquo;re going to roll
out our code with one small command and it will take mere seconds:&lt;/p&gt;

&lt;p&gt;Note, some text removed for brevity:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@3ce920c5854d:/code/serverless-demo$ sls dash deploy
Serverless: Select the assets you wish to deploy:
    hello
      &amp;gt; function - hello
      endpoint - hello - GET
    - - - - -
  &amp;gt; Deploy
    Cancel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We select &lt;em&gt;just&lt;/em&gt; the function since our API Gateway endpoint isn&amp;rsquo;t changing at all. This took about
20 seconds for me and I&amp;rsquo;ve seen it go faster and slower&amp;hellip;but I&amp;rsquo;ve never seen it take longer than
a minute or so. Once we start pushing up Lambda functions with more requirements the zip files will
be larger and uploads will take slightly longer.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s load it in browser and see what we get now!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;quot;&amp;lt;html&amp;gt;\n    &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;\n    &amp;lt;body&amp;gt;\n        &amp;lt;h1&amp;gt;Hello from Serverless/API Gateway/Lambda&amp;lt;/h1&amp;gt;\n
&amp;lt;h2&amp;gt;Event:&amp;lt;/h2&amp;gt;\n        &amp;lt;pre&amp;gt;\n            {}\n        &amp;lt;/pre&amp;gt;\n        &amp;lt;/body&amp;gt;\n    &amp;lt;/html&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hrm. Not exactly what we were hoping for.&lt;/p&gt;

&lt;p&gt;Remember our &lt;code&gt;Content-Type&lt;/code&gt; header? Let&amp;rsquo;s see what it is now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@bz-cconline(master)$ curl -v -s https://4m98c4l3i1.execute-api.us-west-2.amazonaws.com/dev/hello 2&amp;gt;&amp;amp;1 | grep Content-Type
&amp;lt; Content-Type: application/json;charset=UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yup&amp;hellip;my browser isn&amp;rsquo;t parsing this because it thinks it&amp;rsquo;s JSON. To solve this we need to tell API
Gateway to return &lt;code&gt;text/html&lt;/code&gt;. Honestly, this is &lt;strong&gt;way&lt;/strong&gt; harder than it should be. By default we
saw that API Gateway is setup to return &lt;code&gt;application/json&lt;/code&gt; which worked great out of the box. To
make it return &lt;code&gt;text/html&lt;/code&gt; is much more convoluted and not intuitive in the least. To do this we&amp;rsquo;ll
need to tweak the mappings in API Gateway via the &lt;code&gt;s-function.json&lt;/code&gt; file. I&amp;rsquo;m not going to explain
the details for now mostly because I&amp;rsquo;m still figuring out exactly how these mapping work. For now,
here are the lines you&amp;rsquo;ll need to change:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;responses&amp;quot;: {
    &amp;quot;400&amp;quot;: {
    &amp;quot;statusCode&amp;quot;: &amp;quot;400&amp;quot;
},  
&amp;quot;default&amp;quot;: {
    &amp;quot;statusCode&amp;quot;: &amp;quot;200&amp;quot;,
    &amp;quot;responseParameters&amp;quot;: {
        &amp;quot;method.response.header.Content-Type&amp;quot;: &amp;quot;&#39;text/html&#39;&amp;quot;
    },  
    &amp;quot;responseTemplates&amp;quot;: {
        &amp;quot;text/html&amp;quot;: &amp;quot;$input.path(&#39;$&#39;)&amp;quot;
    }   
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The lines are those with &lt;code&gt;text/html&lt;/code&gt; in them. Now, we just &lt;code&gt;sls dash deploy&lt;/code&gt; again, select just the
endpoint and refresh our browser:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.brianz.bz/images/api-gateway-in-browser-success.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Success!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Serverless is quite amazing and I&amp;rsquo;m very excited by this project. When building SAAS applications
it&amp;rsquo;s quite obvious how much power and flexibility this gives us. Of course, there are limitations
to this type of system and not all problems can be solved with Serverless&amp;hellip;but a lot of them can.&lt;/p&gt;

&lt;p&gt;I will attempt to follow up with more details in future posts&amp;hellip;look for Part III coming soon.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serverless part I</title>
      <link>http://blog.brianz.bz/post/serverless-part-i/</link>
      <pubDate>Wed, 20 Apr 2016 16:08:07 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/serverless-part-i/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s a pretty exciting (and challenging) time to build software-based applications. Every week
there are more and more tools to make our jobs easier or to enable us to focus on &lt;em&gt;application&lt;/em&gt;
development rather than dealing with the infrastructure around those applications. Of course, this
makes our jobs challenging since we need to keep up with the innovation.&lt;/p&gt;

&lt;p&gt;This will be part one of a multi-part series about &amp;ldquo;serverless&amp;rdquo; architecture/design. I hesitate to
call this &amp;ldquo;architecture&amp;rdquo; but it&amp;rsquo;s definitely a way of doing things both from an infrastructure (or
lack of) side and code organization. The possibility of running web applications without any servers
has become a reality fairly recently and kicked off multiple projects around this idea.
What I&amp;rsquo;d like to do in Part I is to simply give an intro to &amp;ldquo;serverless&amp;rdquo; and talk through some moving parts.&lt;/p&gt;

&lt;p&gt;The big question, what is serverless?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Serverless is a way to author a HTTP service using &lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html&#34; target=&#34;_blank&#34;&gt;AWS API
Gateway&lt;/a&gt; and
&lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/welcome.html&#34; target=&#34;_blank&#34;&gt;AWS Lambda&lt;/a&gt; which
eliminates the need to manage or maintain any running servers or EC2 instances. Any servers used to
process HTTP requests are managed by AWS and never exposed to you as the application developer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As a point of clarification, there is a project named Serverless. I&amp;rsquo;ll try to differentiate the
&lt;em&gt;term&lt;/em&gt; &amp;ldquo;serverless&amp;rdquo; from the &lt;em&gt;project&lt;/em&gt; Serverless by capitalizing the project.&lt;/p&gt;

&lt;h2 id=&#34;api-gateway&#34;&gt;API Gateway&lt;/h2&gt;

&lt;p&gt;In July of 2015 &lt;a href=&#34;https://aws.amazon.com/blogs/aws/amazon-api-gateway-build-and-run-scalable-application-backends/&#34; target=&#34;_blank&#34;&gt;AWS released API
Gateway&lt;/a&gt;
which is a service to create and manage public API
endpoints on your behalf. Gateway is comprised of two services really:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;control service to expose a REST endpoint&lt;/li&gt;
&lt;li&gt;execution service to run some code or backend system&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There&amp;rsquo;s much more to it of course so I encourage you to &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html&#34; target=&#34;_blank&#34;&gt;read the docs from
AWS&lt;/a&gt;. For the purpose of
this post we don&amp;rsquo;t need to go into a &lt;em&gt;ton&lt;/em&gt; of detail around API Gateway&amp;hellip;just imagine that you can
click a few buttons (or make some AWS API calls) and wind up with a URL that you can immediately start
hitting with &lt;code&gt;curl&lt;/code&gt; without setting up or managing EC2 instances. This is the first step in the
world of &amp;ldquo;serverless&amp;rdquo;&amp;hellip;getting a pubic HTTP endpoint without managing any servers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Without&lt;/em&gt; API Gateway standing up a webserver which does something as simple as returning and empty
response in response to a query to a public URL is quite an endeavor:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;spin up a cloud server&lt;/li&gt;
&lt;li&gt;install a webserver like nginx&lt;/li&gt;
&lt;li&gt;(optionally) pointing DNS at your cloud server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even if you&amp;rsquo;re skilled at this, it&amp;rsquo;s going to take several minutes. With API Gateway you can
literally accomplish the same thing in 30 seconds. Not only that, you&amp;rsquo;ll be paying every minute
that your EC2 instance is running, regardless of the load. With API Gateway you pay per call.&lt;/p&gt;

&lt;h2 id=&#34;lambda&#34;&gt;Lambda&lt;/h2&gt;

&lt;p&gt;So what is Lambda? &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/welcome.html&#34; target=&#34;_blank&#34;&gt;From Amazon&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;AWS Lambda is a compute service where you can upload your code to AWS Lambda and the service can
run the code on your behalf using AWS infrastructure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What does that mean &lt;em&gt;exactly&lt;/em&gt;?  Well, with Lambda you can&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;author code in Java, Python or JavaScript/Node&lt;/li&gt;
&lt;li&gt;package your code in a zip file&lt;/li&gt;
&lt;li&gt;upload it to the Lambda service&lt;/li&gt;
&lt;li&gt;tell amazon to run your code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What exactly can your code actually &lt;em&gt;do&lt;/em&gt; though?  Again, this is mostly up to you. While there are
some constraints you need to abide by (mostly around execution time and memory) you can do almost
anything. Provided your code has access to any supporting libraries it needs, AWS will take care of
the runtime. Your code is executed based on some trigger and once it&amp;rsquo;s done, poof! There are no
running servers (which you need to manage) which allows you to focus on your code.&lt;/p&gt;

&lt;p&gt;When it&amp;rsquo;s being executed, AWS will magically unpack your code, run it and then be done with it until the next time
it&amp;rsquo;s run. There are several beautiful things about this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No servers to maintain&lt;/li&gt;
&lt;li&gt;Pay by execution time&amp;hellip;no wasted cycles&lt;/li&gt;
&lt;li&gt;Ability to execute a Lambda from various triggers&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;api-gateway-lambda-serverless&#34;&gt;API Gateway + Lambda == Serverless&lt;/h2&gt;

&lt;p&gt;The confluence of API Gateway and Lambda is what serverless is all about. Above I described how
easy it is to build a public URL which doesn&amp;rsquo;t do anything. That&amp;rsquo;s not interesting at all, but
becomes interesting when you can have that API call trigger a Lambda function. Gateway actually
supports different execution services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP proxy&lt;/li&gt;
&lt;li&gt;Mock integration&lt;/li&gt;
&lt;li&gt;AWS Service Proxy&lt;/li&gt;
&lt;li&gt;Lambda function&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;m not going to talk about the first three&amp;hellip;we&amp;rsquo;re really interested in having API Gateway execute
a Lambda function on our behalf.  This is the foundation of serverless&amp;hellip;.API Gateway calls your custom
Lambda function.  Your Lambda function can do whatever you can come up with and provide a response
which is returned to the caller of your HTTP endpoint.  Your Lambda function could:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fetch data from a database&lt;/li&gt;
&lt;li&gt;write data to a database&lt;/li&gt;
&lt;li&gt;kick off some processes with Kinesis&lt;/li&gt;
&lt;li&gt;anything you manage to accomplish with Lambda&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The power of this may or may not have hit you, but here it is: if you can write all of your application code as Lambda
functions you have now created a &lt;strong&gt;completely serverless REST API&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s drill in on this. Imagine making a HTTP call, getting a response
and not having to manage a single EC2 instance (or any other type of server). Furthermore, that
single call cost a fraction of a penny. If you look at the &lt;a href=&#34;https://aws.amazon.com/lambda/pricing/&#34; target=&#34;_blank&#34;&gt;pricing for
Lambda&lt;/a&gt; and &lt;a href=&#34;https://aws.amazon.com/api-gateway/pricing/&#34; target=&#34;_blank&#34;&gt;pricing for
Gateway&lt;/a&gt; you&amp;rsquo;ll get a feel for how cheap this can be.&lt;/p&gt;

&lt;h2 id=&#34;serverless-project&#34;&gt;Serverless project&lt;/h2&gt;

&lt;p&gt;One of my big questions was how this fits into the normal development cycle. Sure, this is
&lt;strong&gt;super&lt;/strong&gt; powerful, but how do I actually &lt;em&gt;use&lt;/em&gt; it in the real world. Other folks are realizing the
power of these systems and as usual, tooling is being built up around the AWS services.&lt;/p&gt;

&lt;p&gt;One of the more popular projects and one which I was referred to by the AWS folks is
&lt;a href=&#34;http://serverless.com&#34; target=&#34;_blank&#34;&gt;http://serverless.com&lt;/a&gt;. There area
others&amp;hellip;here&amp;rsquo;s one to run &lt;a href=&#34;https://github.com/Miserlou/django-zappa&#34; target=&#34;_blank&#34;&gt;Django via Gateway/Lambda&lt;/a&gt;
and yet another one &lt;a href=&#34;https://github.com/Miserlou/flask-zappa&#34; target=&#34;_blank&#34;&gt;doing the same thing with Flask&lt;/a&gt;. I&amp;rsquo;m
sure there are other&amp;hellip;Google &lt;code&gt;&amp;quot;serverless fill-in-the-blank&amp;quot;&lt;/code&gt; and you&amp;rsquo;ll undoubtedly find something
interesting.&lt;/p&gt;

&lt;p&gt;In my initial testing the Serverless project is pretty nice. Since its main job is to wrap API
calls to API Gateway and Lambda you&amp;rsquo;ll need to understand those two services on your own before you
can start building things with Serverless. In my experience that&amp;rsquo;s pretty much always the case with
any tool that wraps AWS services.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s the high level introduction to what serverless is all about. In Part II I&amp;rsquo;ll do a walk
through of the Serverless project and show some real-world examples of how to build something. Stay
tuned!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing servant</title>
      <link>http://blog.brianz.bz/post/introducing-servant/</link>
      <pubDate>Mon, 04 Apr 2016 17:26:23 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/introducing-servant/</guid>
      <description>

&lt;p&gt;Late in 2014 we began the process of discussing a payment system at
&lt;a href=&#34;http://www.clearcareonline.com&#34; target=&#34;_blank&#34;&gt;work&lt;/a&gt;. The system was to have a fairly simple reason for
existing&amp;hellip;to do all the work needed to charge credit cards on behalf of our customers.&lt;/p&gt;

&lt;p&gt;Backing up a bit&amp;hellip;our system is mainly a B2B application. Home care agencies all over the country
run our SAAS application which helps them to run their businesses. Our new Payment System was aimed at allowing
our customers to charge &lt;em&gt;their&lt;/em&gt; customers&amp;rsquo; credit cards directly, meaning our customers don&amp;rsquo;t need
to wait for checks or paper invoicing. Our SAAS is a pretty typical Python stack with the &lt;strong&gt;major&lt;/strong&gt;
components being:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;monolithic Django app&lt;/li&gt;
&lt;li&gt;Postgres&lt;/li&gt;
&lt;li&gt;Elasticsearch&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Celery/RabbitMQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For us it was pretty clear that we wanted to build this as a stand-alone service and stick with
Python. Yeah&amp;hellip;we wanted a &lt;em&gt;microservice&lt;/em&gt; which is all the rage now. We knew that we needed to
start evolving our architecture and services, while having their own sets of challenges, make a lot
of sense. In late 2014 the issue was that there really wasn&amp;rsquo;t (and still aren&amp;rsquo;t) many existing and
proven frameworks for building services in Python.&lt;/p&gt;

&lt;h2 id=&#34;enter-servant&#34;&gt;Enter servant&lt;/h2&gt;

&lt;p&gt;Leaning on a custom service framework I had worked with while at
&lt;a href=&#34;http://eventbrite.com&#34; target=&#34;_blank&#34;&gt;Eventbrite&lt;/a&gt; I came up with servant. You can see the project page on Github.
We currently have multiple services deployed in production at Clearcare based on servant and so
far, they&amp;rsquo;ve been working great:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/clearcare/servant&#34; target=&#34;_blank&#34;&gt;https://github.com/clearcare/servant&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What exactly is this library? At a very high level servant is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a Python library/framework for authoring and communicating with services&lt;/li&gt;
&lt;li&gt;to services what Django/Flask/Rails are to web applications&lt;/li&gt;
&lt;li&gt;designed primarily for &lt;em&gt;internal&lt;/em&gt; non-publicly facing services&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Servant is actually pretty simple and doesn&amp;rsquo;t perform much magic.  What it does do
is give you, the service author, a framework for designing RPC-style services in Python which
can run on their own, independently, and are easy to connect to and interface with. In addition,
it&amp;rsquo;s not an opinionated framework so you can choose whatever tooling you&amp;rsquo;d like in order to author
your service. Our typical recipe at work includes pytest for testing and sqlalchemy for talking to
the Postgres. However, you use whatever you want depending on your needs&amp;hellip;servant stays out of
your way and deals with executing service calls on behalf of the client. There is some validation
here and there to ensure the service call is well-formed but I won&amp;rsquo;t go over that right now.&lt;/p&gt;

&lt;h2 id=&#34;quick-code-examples&#34;&gt;Quick code examples&lt;/h2&gt;

&lt;p&gt;When I first started using services I had no idea what looked like both authoring a service or
talking to a service. If you have never worked with a service framework you may think it&amp;rsquo;s a matter
of writing or talking to a REST endpoint. Servant is a bit different&amp;hellip;so here are a few small code
snippets which should make things more clear.&lt;/p&gt;

&lt;p&gt;In this example, we&amp;rsquo;ll create a silly little &amp;ldquo;Calculator Service&amp;rdquo;. I&amp;rsquo;ll implement an &lt;code&gt;add&lt;/code&gt; endpoint
which will take two numbers, add them up and return the sum.&lt;/p&gt;

&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;

&lt;p&gt;As a client, the only dependencies is having the servant library installed. You could call this
from a Django app, one-off script&amp;hellip;wherever. Install servant from github. Here I install it into a
virtualenv using virtualenvwrapper:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brianz@gold$ mkvirtualenv test_servant

(test_servant)brianz@gold$ pip install git+https://github.com/clearcare/servant.git@master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, I can write some client code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# test_add.py
import servant.client

client = servant.client.Client(&#39;calculator_service&#39;, version=1)

# add is the actual endpoint we&#39;re calling
response = client.add(number1=10, number2=15)

if response.is_error():
    print response.errors, response.field_errors
else:
    print response.result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s about it for client code! Provided you have a service named &lt;code&gt;calculator_service&lt;/code&gt; available,
this code will work and spit out the expected result of &lt;code&gt;25&lt;/code&gt;. You can actually install
&lt;code&gt;calculator_service&lt;/code&gt; yourself and run this code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(test_servant)brianz@gold$ cd servant/examples/calculator_service/
(test_servant)brianz@gold$ pip install .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(test_servant)brianz@bz-cconline$ python test_calculator.py 
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s how you actually &lt;em&gt;use&lt;/em&gt; a servant service. How do you author one?&lt;/p&gt;

&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;

&lt;p&gt;Authoring a service is a bit more work but still quite easy. This is how you&amp;rsquo;d implement the &lt;code&gt;add&lt;/code&gt;
method we used above. Note you can also &lt;a href=&#34;https://github.com/clearcare/servant/tree/master/examples/calculator_service&#34; target=&#34;_blank&#34;&gt;peruse the
&lt;code&gt;calculator_service&lt;/code&gt;&lt;/a&gt;
to see a more thorough implemenation..but the below code will actually work.&lt;/p&gt;

&lt;p&gt;First, you need to define a single &lt;code&gt;service.py&lt;/code&gt; file which defines your service and declares all
its endpoints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# service.py
from servant.service.base import Service

import actions

class Calculator(Service):

    name = &#39;calculator_service&#39;
    version = 1 

    action_map = { 
            &#39;add&#39;: actions.AddAction,
            # we won&#39;t implement subtract now
            # &#39;subtract&#39;: actions.SubtractAction,
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, you&amp;rsquo;ll need to create one or more actions. Note above we import &lt;code&gt;actions&lt;/code&gt; and point to two
different action classes&amp;hellip;we&amp;rsquo;ll only show one here for brevity. But, how you map endpoint
names to actions is entirely up to you. We always have an &lt;code&gt;actions/&lt;/code&gt; directory with different
actions broken up by area of responsibility. Again, for brevity we&amp;rsquo;ll just show a single action for
our calculator service.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# actions.py
import servant.fields
from servant.service.actions import Action

class AddAction(Action):
    number1 = servant.fields.IntField(
            required=True,
            in_response=True,
    )   
    number2 = servant.fields.IntField(
            required=True,
            in_response=True,
    )   
    result = servant.fields.IntField(
            in_response=True,
    )   

    def run(self, **kwargs):
        self.result = self.number1 + self.number2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you ignore &lt;code&gt;setup.py&lt;/code&gt; and any other packaging code or files, our actual service is only a few
files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(test_servant)brianz@gold$ tree
├── __init__.py
├── actions.py
└── service.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can imagine what &lt;code&gt;SubtractAction&lt;/code&gt; would look like. From there, provided you
can install your service as a Python package, this code is fully functional. You can see all of
this and actually give it a try&amp;hellip;clone the repo and look in
the &lt;a href=&#34;https://github.com/clearcare/servant/tree/master/examples/calculator_service&#34; target=&#34;_blank&#34;&gt;the examples directory&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;local-library-mode&#34;&gt;Local library mode&lt;/h2&gt;

&lt;p&gt;One killer feature IMO which I have only seen in Eventbrite&amp;rsquo;s SOA library is that of local mode.
You&amp;rsquo;ll notice in all of the code above, there is no mention or reference to where the service is
running. You didn&amp;rsquo;t event start a server. Where is the client connecting? How does the client code
know where to connect? What port is the server running on?&lt;/p&gt;

&lt;p&gt;When you author a service and are able to install it as a Python package, you can talk to it just
as if it were running on a remote system. The magic here is that the servant client code imports
your service and executes it as a local library.  When you&amp;rsquo;re ready to deploy your service
somewhere else and point your clients to the &lt;em&gt;real&lt;/em&gt; server, it&amp;rsquo;s a one line change:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import servant.client

client = servant.client.Client(&#39;calculator_service&#39;, version=1)
# Now point your client to the remote host
client.configure(&#39;remote-host-name-or-ip&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The big advantage to this is that it&amp;rsquo;s trivially easy to start developing and testing your service.
Unit testing is &lt;em&gt;really&lt;/em&gt; easy.  The code which gets executed is almost exactly the same. Of course,
running on a real server rather than as a local library cannot be &lt;em&gt;identical&lt;/em&gt;, but it&amp;rsquo;s quite close
and any differences are definitely worth the increase in productivity.&lt;/p&gt;

&lt;h2 id=&#34;why-servant&#34;&gt;Why servant?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;This is dumb, REST rules!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hey, we (mostly) all like REST&amp;hellip;it&amp;rsquo;s great, but has some limitations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP  by definition&lt;/li&gt;
&lt;li&gt;Requires a running server&lt;/li&gt;
&lt;li&gt;Usually end up using a wrapper library&lt;/li&gt;
&lt;li&gt;Various interpretations&lt;/li&gt;
&lt;li&gt;Can be challenging to get your Resources right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Being a RPC-style library, with servant:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Transport/broker can be anything (library call, HTTP, Redis, ØMQ, RabbitMQ&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Develop quickly with local library mode&lt;/li&gt;
&lt;li&gt;RPC endpoints can be more descriptive&amp;hellip;no need to interpret PUT vs POST&lt;/li&gt;
&lt;li&gt;ONE way of implementing a service vs. author&amp;rsquo;s interpretation of REST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In terms of the transport, we currently have implementations for local mode and HTTP mode. If you
look at the
&lt;a href=&#34;https://github.com/clearcare/servant/blob/master/examples/calculator_service/README.md&#34; target=&#34;_blank&#34;&gt;README&lt;/a&gt;
you&amp;rsquo;ll see example of how to run the demo via &lt;code&gt;uwsgi&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;trade-offs&#34;&gt;Trade offs&lt;/h2&gt;

&lt;p&gt;As with any technology there are trade-offs. Here are a few issues with servant today:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Currently Python only. Other languages would need a Servant library implemented.&lt;/li&gt;
&lt;li&gt;No mechanism for exploration&amp;hellip;need knowledge of service before hitting it&lt;/li&gt;
&lt;li&gt;Can&amp;rsquo;t simply use curl to hit an endpoint&lt;/li&gt;
&lt;li&gt;Need another layer to expose a service publicly (i.e., hitting from JavaScript)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;closing-thoughts&#34;&gt;Closing thoughts&lt;/h2&gt;

&lt;p&gt;Servant has served us quite well at work and I really would like to keep iterating on it. It&amp;rsquo;s open
source, so if you&amp;rsquo;re interested clone the repo and give it a try. I haven&amp;rsquo;t looked at the current
landscape for service libraries in Python in a while but know that others are popping up here and
there. Still, I do know that there aren&amp;rsquo;t any really big libraries that the community if flocking
to when starting their journey into a microservice architecture. From what I can tell people mostly
reach for a REST or REST-like design when building services.&lt;/p&gt;

&lt;p&gt;In a future post I&amp;rsquo;ll go into some more detail about servant and some ideas that I&amp;rsquo;ve had but
haven&amp;rsquo;t been implemented yet.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>