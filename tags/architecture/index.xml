<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on Brian Z</title>
    <link>http://blog.brianz.bz/tags/architecture/</link>
    <description>Recent content in Architecture on Brian Z</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 16:08:07 -0600</lastBuildDate>
    <atom:link href="http://blog.brianz.bz/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Serverless part I</title>
      <link>http://blog.brianz.bz/post/serverless-part-i/</link>
      <pubDate>Wed, 20 Apr 2016 16:08:07 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/serverless-part-i/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s a pretty exciting (and challenging) time to build software-based applications. Every week
there are more and more tools to make our jobs easier or to enable us to focus on &lt;em&gt;application&lt;/em&gt;
development rather than dealing with the infrastructure around those applications. Of course, this
makes our jobs challenging since we need to keep up with the innovation.&lt;/p&gt;

&lt;p&gt;This will be part one of a multi-part series about &amp;ldquo;serverless&amp;rdquo; architecture/design. I hesitate to
call this &amp;ldquo;architecture&amp;rdquo; but it&amp;rsquo;s definitely a way of doing things both from an infrastructure (or
lack of) side and code organization. The possibility of running web applications without any servers
has become a reality fairly recently and kicked off multiple projects around this idea.
What I&amp;rsquo;d like to do in Part I is to simply give an intro to &amp;ldquo;serverless&amp;rdquo; and talk through some moving parts.&lt;/p&gt;

&lt;p&gt;The big question, what is serverless?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Serverless is a way to author a HTTP service using &lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html&#34; target=&#34;_blank&#34;&gt;AWS API
Gateway&lt;/a&gt; and
&lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/welcome.html&#34; target=&#34;_blank&#34;&gt;AWS Lambda&lt;/a&gt; which
eliminates the need to manage or maintain any running servers or EC2 instances. Any servers used to
process HTTP requests are managed by AWS and never exposed to you as the application developer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As a point of clarification, there is a project named Serverless. I&amp;rsquo;ll try to differentiate the
&lt;em&gt;term&lt;/em&gt; &amp;ldquo;serverless&amp;rdquo; from the &lt;em&gt;project&lt;/em&gt; Serverless by capitalizing the project.&lt;/p&gt;

&lt;h2 id=&#34;api-gateway:16049c44302f91a3835f9f8afd5f9708&#34;&gt;API Gateway&lt;/h2&gt;

&lt;p&gt;In July of 2015 &lt;a href=&#34;https://aws.amazon.com/blogs/aws/amazon-api-gateway-build-and-run-scalable-application-backends/&#34; target=&#34;_blank&#34;&gt;AWS released API
Gateway&lt;/a&gt;
which is a service to create and manage public API
endpoints on your behalf. Gateway is comprised of two services really:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;control service to expose a REST endpoint&lt;/li&gt;
&lt;li&gt;execution service to run some code or backend system&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There&amp;rsquo;s much more to it of course so I encourage you to &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html&#34; target=&#34;_blank&#34;&gt;read the docs from
AWS&lt;/a&gt;. For the purpose of
this post we don&amp;rsquo;t need to go into a &lt;em&gt;ton&lt;/em&gt; of detail around API Gateway&amp;hellip;just imagine that you can
click a few buttons (or make some AWS API calls) and wind up with a URL that you can immediately start
hitting with &lt;code&gt;curl&lt;/code&gt; without setting up or managing EC2 instances. This is the first step in the
world of &amp;ldquo;serverless&amp;rdquo;&amp;hellip;getting a pubic HTTP endpoint without managing any servers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Without&lt;/em&gt; API Gateway standing up a webserver which does something as simple as returning and empty
response in response to a query to a public URL is quite an endeavor:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;spin up a cloud server&lt;/li&gt;
&lt;li&gt;install a webserver like nginx&lt;/li&gt;
&lt;li&gt;(optionally) pointing DNS at your cloud server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even if you&amp;rsquo;re skilled at this, it&amp;rsquo;s going to take several minutes. With API Gateway you can
literally accomplish the same thing in 30 seconds. Not only that, you&amp;rsquo;ll be paying every minute
that your EC2 instance is running, regardless of the load. With API Gateway you pay per call.&lt;/p&gt;

&lt;h2 id=&#34;lambda:16049c44302f91a3835f9f8afd5f9708&#34;&gt;Lambda&lt;/h2&gt;

&lt;p&gt;So what is Lambda? &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/welcome.html&#34; target=&#34;_blank&#34;&gt;From Amazon&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;AWS Lambda is a compute service where you can upload your code to AWS Lambda and the service can
run the code on your behalf using AWS infrastructure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What does that mean &lt;em&gt;exactly&lt;/em&gt;?  Well, with Lambda you can&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;author code in Java, Python or JavaScript/Node&lt;/li&gt;
&lt;li&gt;package your code in a zip file&lt;/li&gt;
&lt;li&gt;upload it to the Lambda service&lt;/li&gt;
&lt;li&gt;tell amazon to run your code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What exactly can your code actually &lt;em&gt;do&lt;/em&gt; though?  Again, this is mostly up to you. While there are
some constraints you need to abide by (mostly around execution time and memory) you can do almost
anything. Provided your code has access to any supporting libraries it needs, AWS will take care of
the runtime. Your code is executed based on some trigger and once it&amp;rsquo;s done, poof! There are no
running servers (which you need to manage) which allows you to focus on your code.&lt;/p&gt;

&lt;p&gt;When it&amp;rsquo;s being executed, AWS will magically unpack your code, run it and then be done with it until the next time
it&amp;rsquo;s run. There are several beautiful things about this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No servers to maintain&lt;/li&gt;
&lt;li&gt;Pay by execution time&amp;hellip;no wasted cycles&lt;/li&gt;
&lt;li&gt;Ability to execute a Lambda from various triggers&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;api-gateway-lambda-serverless:16049c44302f91a3835f9f8afd5f9708&#34;&gt;API Gateway + Lambda == Serverless&lt;/h2&gt;

&lt;p&gt;The confluence of API Gateway and Lambda is what serverless is all about. Above I described how
easy it is to build a public URL which doesn&amp;rsquo;t do anything. That&amp;rsquo;s not interesting at all, but
becomes interesting when you can have that API call trigger a Lambda function. Gateway actually
supports different execution services:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP proxy&lt;/li&gt;
&lt;li&gt;Mock integration&lt;/li&gt;
&lt;li&gt;AWS Service Proxy&lt;/li&gt;
&lt;li&gt;Lambda function&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;m not going to talk about the first three&amp;hellip;we&amp;rsquo;re really interested in having API Gateway execute
a Lambda function on our behalf.  This is the foundation of serverless&amp;hellip;.API Gateway calls your custom
Lambda function.  Your Lambda function can do whatever you can come up with and provide a response
which is returned to the caller of your HTTP endpoint.  Your Lambda function could:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fetch data from a database&lt;/li&gt;
&lt;li&gt;write data to a database&lt;/li&gt;
&lt;li&gt;kick off some processes with Kinesis&lt;/li&gt;
&lt;li&gt;anything you manage to accomplish with Lambda&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The power of this may or may not have hit you, but here it is: if you can write all of your application code as Lambda
functions you have now created a &lt;strong&gt;completely serverless REST API&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s drill in on this. Imagine making a HTTP call, getting a response
and not having to manage a single EC2 instance (or any other type of server). Furthermore, that
single call cost a fraction of a penny. If you look at the &lt;a href=&#34;https://aws.amazon.com/lambda/pricing/&#34; target=&#34;_blank&#34;&gt;pricing for
Lambda&lt;/a&gt; and &lt;a href=&#34;https://aws.amazon.com/api-gateway/pricing/&#34; target=&#34;_blank&#34;&gt;pricing for
Gateway&lt;/a&gt; you&amp;rsquo;ll get a feel for how cheap this can be.&lt;/p&gt;

&lt;h2 id=&#34;serverless-project:16049c44302f91a3835f9f8afd5f9708&#34;&gt;Serverless project&lt;/h2&gt;

&lt;p&gt;One of my big questions was how this fits into the normal development cycle. Sure, this is
&lt;strong&gt;super&lt;/strong&gt; powerful, but how do I actually &lt;em&gt;use&lt;/em&gt; it in the real world. Other folks are realizing the
power of these systems and as usual, tooling is being built up around the AWS services.&lt;/p&gt;

&lt;p&gt;One of the more popular projects and one which I was referred to by the AWS folks is
&lt;a href=&#34;http://serverless.com&#34; target=&#34;_blank&#34;&gt;http://serverless.com&lt;/a&gt;. There area
others&amp;hellip;here&amp;rsquo;s one to run &lt;a href=&#34;https://github.com/Miserlou/django-zappa&#34; target=&#34;_blank&#34;&gt;Django via Gateway/Lambda&lt;/a&gt;
and yet another one &lt;a href=&#34;https://github.com/Miserlou/flask-zappa&#34; target=&#34;_blank&#34;&gt;doing the same thing with Flask&lt;/a&gt;. I&amp;rsquo;m
sure there are other&amp;hellip;Google &lt;code&gt;&amp;quot;serverless fill-in-the-blank&amp;quot;&lt;/code&gt; and you&amp;rsquo;ll undoubtedly find something
interesting.&lt;/p&gt;

&lt;p&gt;In my initial testing the Serverless project is pretty nice. Since its main job is to wrap API
calls to API Gateway and Lambda you&amp;rsquo;ll need to understand those two services on your own before you
can start building things with Serverless. In my experience that&amp;rsquo;s pretty much always the case with
any tool that wraps AWS services.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s the high level introduction to what serverless is all about. In Part II I&amp;rsquo;ll do a walk
through of the Serverless project and show some real-world examples of how to build something. Stay
tuned!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing servant</title>
      <link>http://blog.brianz.bz/post/introducting-servant/</link>
      <pubDate>Mon, 04 Apr 2016 17:26:23 -0600</pubDate>
      
      <guid>http://blog.brianz.bz/post/introducting-servant/</guid>
      <description>

&lt;p&gt;Late in 2014 we began the process of discussing a payment system at
&lt;a href=&#34;http://www.clearcareonline.com&#34; target=&#34;_blank&#34;&gt;work&lt;/a&gt;. The system was to have a fairly simple reason for
existing&amp;hellip;to do all the work needed to charge credit cards on behalf of our customers.&lt;/p&gt;

&lt;p&gt;Backing up a bit&amp;hellip;our system is mainly a B2B application. Home care agencies all over the country
run our SAAS application which helps them to run their businesses. Our new Payment System was aimed at allowing
our customers to charge &lt;em&gt;their&lt;/em&gt; customers&amp;rsquo; credit cards directly, meaning our customers don&amp;rsquo;t need
to wait for checks or paper invoicing. Our SAAS is a pretty typical Python stack with the &lt;strong&gt;major&lt;/strong&gt;
components being:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;monolithic Django app&lt;/li&gt;
&lt;li&gt;Postgres&lt;/li&gt;
&lt;li&gt;Elasticsearch&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Celery/RabbitMQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For us it was pretty clear that we wanted to build this as a stand-alone service and stick with
Python. Yeah&amp;hellip;we wanted a &lt;em&gt;microservice&lt;/em&gt; which is all the rage now. We knew that we needed to
start evolving our architecture and services, while having their own sets of challenges, make a lot
of sense. In late 2014 the issue was that there really wasn&amp;rsquo;t (and still aren&amp;rsquo;t) many existing and
proven frameworks for building services in Python.&lt;/p&gt;

&lt;h2 id=&#34;enter-servant:9879b9e4b526681137999e709cb09eff&#34;&gt;Enter servant&lt;/h2&gt;

&lt;p&gt;Leaning on a custom service framework I had worked with while at
&lt;a href=&#34;http://eventbrite.com&#34; target=&#34;_blank&#34;&gt;Eventbrite&lt;/a&gt; I came up with servant. You can see the project page on Github.
We currently have multiple services deployed in production at Clearcare based on servant and so
far, they&amp;rsquo;ve been working great:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/clearcare/servant&#34; target=&#34;_blank&#34;&gt;https://github.com/clearcare/servant&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What exactly is this library? At a very high level servant is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a Python library/framework for authoring and communicating with services&lt;/li&gt;
&lt;li&gt;to services what Django/Flask/Rails are to web applications&lt;/li&gt;
&lt;li&gt;designed primarily for &lt;em&gt;internal&lt;/em&gt; non-publicly facing services&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Servant is actually pretty simple and doesn&amp;rsquo;t perform much magic.  What it does do
is give you, the service author, a framework for designing RPC-style services in Python which
can run on their own, independently, and are easy to connect to and interface with. In addition,
it&amp;rsquo;s not an opinionated framework so you can choose whatever tooling you&amp;rsquo;d like in order to author
your service. Our typical recipe at work includes pytest for testing and sqlalchemy for talking to
the Postgres. However, you use whatever you want depending on your needs&amp;hellip;servant stays out of
your way and deals with executing service calls on behalf of the client. There is some validation
here and there to ensure the service call is well-formed but I won&amp;rsquo;t go over that right now.&lt;/p&gt;

&lt;h2 id=&#34;quick-code-examples:9879b9e4b526681137999e709cb09eff&#34;&gt;Quick code examples&lt;/h2&gt;

&lt;p&gt;When I first started using services I had no idea what looked like both authoring a service or
talking to a service. If you have never worked with a service framework you may think it&amp;rsquo;s a matter
of writing or talking to a REST endpoint. Servant is a bit different&amp;hellip;so here are a few small code
snippets which should make things more clear.&lt;/p&gt;

&lt;p&gt;In this example, we&amp;rsquo;ll create a silly little &amp;ldquo;Calculator Service&amp;rdquo;. I&amp;rsquo;ll implement an &lt;code&gt;add&lt;/code&gt; endpoint
which will take two numbers, add them up and return the sum.&lt;/p&gt;

&lt;h3 id=&#34;client:9879b9e4b526681137999e709cb09eff&#34;&gt;Client&lt;/h3&gt;

&lt;p&gt;As a client, the only dependencies is having the servant library installed. You could call this
from a Django app, one-off script&amp;hellip;wherever. Install servant from github. Here I install it into a
virtualenv using virtualenvwrapper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brianz@gold$ mkvirtualenv test_servant

(test_servant)brianz@gold$ pip install git+https://github.com/clearcare/servant.git@master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, I can write some client code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# test_add.py
import servant.client

client = servant.client.Client(&#39;calculator_service&#39;, version=1)

# add is the actual endpoint we&#39;re calling
response = client.add(number1=10, number2=15)

if response.is_error():
    print response.errors, response.field_errors
else:
    print response.result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s about it for client code! Provided you have a service named &lt;code&gt;calculator_service&lt;/code&gt; available,
this code will work and spit out the expected result of &lt;code&gt;25&lt;/code&gt;. You can actually install
&lt;code&gt;calculator_service&lt;/code&gt; yourself and run this code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(test_servant)brianz@gold$ cd servant/examples/calculator_service/
(test_servant)brianz@gold$ pip install .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(test_servant)brianz@bz-cconline$ python test_calculator.py 
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s how you actually &lt;em&gt;use&lt;/em&gt; a servant service. How do you author one?&lt;/p&gt;

&lt;h3 id=&#34;server:9879b9e4b526681137999e709cb09eff&#34;&gt;Server&lt;/h3&gt;

&lt;p&gt;Authoring a service is a bit more work but still quite easy. This is how you&amp;rsquo;d implement the &lt;code&gt;add&lt;/code&gt;
method we used above. Note you can also &lt;a href=&#34;https://github.com/clearcare/servant/tree/master/examples/calculator_service&#34; target=&#34;_blank&#34;&gt;peruse the
&lt;code&gt;calculator_service&lt;/code&gt;&lt;/a&gt;
to see a more thorough implemenation..but the below code will actually work.&lt;/p&gt;

&lt;p&gt;First, you need to define a single &lt;code&gt;service.py&lt;/code&gt; file which defines your service and declares all
its endpoints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# service.py
from servant.service.base import Service

import actions

class Calculator(Service):

    name = &#39;calculator_service&#39;
    version = 1 

    action_map = { 
            &#39;add&#39;: actions.AddAction,
            # we won&#39;t implement subtract now
            # &#39;subtract&#39;: actions.SubtractAction,
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, you&amp;rsquo;ll need to create one or more actions. Note above we import &lt;code&gt;actions&lt;/code&gt; and point to two
different action classes&amp;hellip;we&amp;rsquo;ll only show one here for brevity. But, how you map endpoint
names to actions is entirely up to you. We always have an &lt;code&gt;actions/&lt;/code&gt; directory with different
actions broken up by area of responsibility. Again, for brevity we&amp;rsquo;ll just show a single action for
our calculator service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# actions.py
import servant.fields
from servant.service.actions import Action

class AddAction(Action):
    number1 = servant.fields.IntField(
            required=True,
            in_response=True,
    )   
    number2 = servant.fields.IntField(
            required=True,
            in_response=True,
    )   
    result = servant.fields.IntField(
            in_response=True,
    )   

    def run(self, **kwargs):
        self.result = self.number1 + self.number2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you ignore &lt;code&gt;setup.py&lt;/code&gt; and any other packaging code or files, our actual service is only a few
files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(test_servant)brianz@gold$ tree
├── __init__.py
├── actions.py
└── service.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can imagine what &lt;code&gt;SubtractAction&lt;/code&gt; would look like. From there, provided you
can install your service as a Python package, this code is fully functional. You can see all of
this and actually give it a try&amp;hellip;clone the repo and look in
the &lt;a href=&#34;https://github.com/clearcare/servant/tree/master/examples/calculator_service&#34; target=&#34;_blank&#34;&gt;the examples directory&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;local-library-mode:9879b9e4b526681137999e709cb09eff&#34;&gt;Local library mode&lt;/h2&gt;

&lt;p&gt;One killer feature IMO which I have only seen in Eventbrite&amp;rsquo;s SOA library is that of local mode.
You&amp;rsquo;ll notice in all of the code above, there is no mention or reference to where the service is
running. You didn&amp;rsquo;t event start a server. Where is the client connecting? How does the client code
know where to connect? What port is the server running on?&lt;/p&gt;

&lt;p&gt;When you author a service and are able to install it as a Python package, you can talk to it just
as if it were running on a remote system. The magic here is that the servant client code imports
your service and executes it as a local library.  When you&amp;rsquo;re ready to deploy your service
somewhere else and point your clients to the &lt;em&gt;real&lt;/em&gt; server, it&amp;rsquo;s a one line change:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import servant.client

client = servant.client.Client(&#39;calculator_service&#39;, version=1)
# Now point your client to the remote host
client.configure(&#39;remote-host-name-or-ip&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The big advantage to this is that it&amp;rsquo;s trivially easy to start developing and testing your service.
Unit testing is &lt;em&gt;really&lt;/em&gt; easy.  The code which gets executed is almost exactly the same. Of course,
running on a real server rather than as a local library cannot be &lt;em&gt;identical&lt;/em&gt;, but it&amp;rsquo;s quite close
and any differences are definitely worth the increase in productivity.&lt;/p&gt;

&lt;h2 id=&#34;why-servant:9879b9e4b526681137999e709cb09eff&#34;&gt;Why servant?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;This is dumb, REST rules!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hey, we (mostly) all like REST&amp;hellip;it&amp;rsquo;s great, but has some limitations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP  by definition&lt;/li&gt;
&lt;li&gt;Requires a running server&lt;/li&gt;
&lt;li&gt;Usually end up using a wrapper library&lt;/li&gt;
&lt;li&gt;Various interpretations&lt;/li&gt;
&lt;li&gt;Can be challenging to get your Resources right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Being a RPC-style library, with servant:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Transport/broker can be anything (library call, HTTP, Redis, ØMQ, RabbitMQ&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Develop quickly with local library mode&lt;/li&gt;
&lt;li&gt;RPC endpoints can be more descriptive&amp;hellip;no need to interpret PUT vs POST&lt;/li&gt;
&lt;li&gt;ONE way of implementing a service vs. author&amp;rsquo;s interpretation of REST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In terms of the transport, we currently have implementations for local mode and HTTP mode. If you
look at the
&lt;a href=&#34;https://github.com/clearcare/servant/blob/master/examples/calculator_service/README.md&#34; target=&#34;_blank&#34;&gt;README&lt;/a&gt;
you&amp;rsquo;ll see example of how to run the demo via &lt;code&gt;uwsgi&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;trade-offs:9879b9e4b526681137999e709cb09eff&#34;&gt;Trade offs&lt;/h2&gt;

&lt;p&gt;As with any technology there are trade-offs. Here are a few issues with servant today:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Currently Python only. Other languages would need a Servant library implemented.&lt;/li&gt;
&lt;li&gt;No mechanism for exploration&amp;hellip;need knowledge of service before hitting it&lt;/li&gt;
&lt;li&gt;Can&amp;rsquo;t simply use curl to hit an endpoint&lt;/li&gt;
&lt;li&gt;Need another layer to expose a service publicly (i.e., hitting from JavaScript)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;closing-thoughts:9879b9e4b526681137999e709cb09eff&#34;&gt;Closing thoughts&lt;/h2&gt;

&lt;p&gt;Servant has served us quite well at work and I really would like to keep iterating on it. It&amp;rsquo;s open
source, so if you&amp;rsquo;re interested clone the repo and give it a try. I haven&amp;rsquo;t looked at the current
landscape for service libraries in Python in a while but know that others are popping up here and
there. Still, I do know that there aren&amp;rsquo;t any really big libraries that the community if flocking
to when starting their journey into a microservice architecture. From what I can tell people mostly
reach for a REST or REST-like design when building services.&lt;/p&gt;

&lt;p&gt;In a future post I&amp;rsquo;ll go into some more detail about servant and some ideas that I&amp;rsquo;ve had but
haven&amp;rsquo;t been implemented yet.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>